1장에서 도메인 모델과 값 객체에 대해 나오는데, 값 객체는 불변이 좋다는 것과 도메인 모델에 set 메서드 넣지 않기 등의 내용이 있는데 이건 알고 있었어.

2장은 아키텍처 개요에 관한 내용이다, 표현, 응용, 도메인, 인프라스트럭처의 의존성에 대해 간략히 설명하고 그 해결 방법으로 DIP에 대해 설명하는데 이 부분도 알고 있던거야. 근데 여기서 좀 기억해야할건, DIP는 단순히 인터페이스와 구현 클래스를 분리하는게 아니라 저수준 모듈과 고수준 모듈을 분리하는 것이다 정도 ???

3장부터 조금씩 내용이 복잡해지기 시작한다, 애그리거트 관련한 내용이다. 애그리거트, 애그리거트 루트 등 이해할 수 있게 상세히 내용을 써준다. 한 애그리거트에서는 하나의 트랜잭션만 처리하는게 좋다. 이 부분과 부득이하게 한 트랜잭션에서 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접수정하는게 아닌 응용 서비스에서 두 애그리거트를 수정할 수 있도록, 좀 더 개선하면 도메인 이벤트를 사용하여 동기나 비동기로 다른 애그리거트의 상태를 변경하는 방법이 있다는걸 알게됨.

애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야한다는 것.
애그리거트에서 다른 애그리거트를 참조할때는 객체 참조가 아닌 id를 이용해 참조할 것.
애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것 고려하는 것.



그리고 대망의 4장… 너무 도움이 많이 됐다.
사실 4장이 아닌 도메인을 연결해주는 매개체에 대한 내용은 꽤 쉽다. 하지만 도메인 영역을 잘 구현하지 않으면 제대로된 소프트웨어를 만들지 못한다.
스프링 데이터 JPA로 리파지토리를 구현하는 법을 알려주는데, 정말 도움이 많이 됐다. 
엔티티 <-> 밸류 구현, @ElementCollection, @Access, @EmbeddedId, @Converter, 애그리거트에서 애그리거트로 참조시 객체 참조가 아닌 id 참조쓸 것,
애그리거트 로딩 전략(애그리거트는 완전해야하지만 루트 엔티티를 로딩하는 시점에 애그리거트에 속한객체를 모두 로딩해야 하는 것은 아니다.)
즉시 로딩의 경우 성능 검토가 필요하다. 1:n 관계의 테이블이 두개 이상이면 카테시안 곱이 발생하기 때문에.
애그리거트의 영속성 전파, 루트를 조회할 때 뿐만 아니라 저장하고 삭제할 때도 하나로 처리해야한다.

6장은 응용 서비스와 표현 영역, 7장은 도메인 서비스에 대한 것이다. 
응용 서비스에 로직을 넣었을때 코드의 응집성이 떨어지고, 코드 중복이 발생한다는 단점이 발생한다. 
또한 각 계층에서의 역할 이를테면 서비스에서 표현 계층으로 엔티티를 반환하지 않는것 등, 응용서비스에서 표현영역의 HttpServletRequest 등을 의존하지 않는것. 과 같은 내용과
각 계층에서 유효성 검증 및 권한 검사에 대해 간략히 다룬다. 도메인 서비스에서는 한 애그리거트에 넣기 애매한 도메인 기능을 억지로 특정 애그리거트에 구현하면 안된다는 내용이 담겨있다. 객체지향적으로 설계하기위해 억지로 도메인 모델에 넣는것 자체가 과한 책임을 가지는 것이기에 위반이다. 이럴때 도메인 서비스를 사용한다. 특정 기능이 응용 서비스인지 도메인 서비스인지 감을 잡기 어려울 때는 해당 로직이 애그리거트의 상태를 변경 하거나 애그리거트의 상태 값을 계산하는지 검사해보면 된다.
외부 시스템 연동 관련된 것도 도메인 서비스가 될 수 있다.	

8장은 애그리거트와 트랜잭션 관련된 부분이다.
한 주문 애그리거트에 대해 운영자는 배송 상태로 변경하 ㄹ때 사용자는 배송지 주소를 변경하면 어떻게 될까? 
운영자는 기존 배송지 정보를 이용해서 배송 상태로 변경했는데 그 사이 고객은 배송지 정보를 변경했다는 점이다. 즉 애그리거트의 일관성이 깨지는 것이다.
이와 같은 문제를 방지하기 위해 다음 두 가지 내용중 하나를 해야한다
- 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안, 고객이 애그리거트를 수정하지 못하게 막는다.
- 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면, 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다.

위 내용에 대해 Pessimistic Lock과 Optimistic Lock의 두 가지 방식으로 트랜잭션 처리를 할 수 있는데 위 내용에 대해서도 3년차 개발자 정도면 이해할 수 있을 정도록 친절히 적혀져있다.

9 장에서는 바운디드 컨텍스트에 대해 다룬다.
하나의 도메인 모델로 모든 도메인을 표현하는, 완벽한 모델을 만들 수 있을까? 그렇지 않다. 각 모델은 명시적으로 구분되는 경계를 가져서 섞이지 않도록 해야한다. 이렇게를 갖는 컨텍스트를 바운디드 컨텍스트라고 한다.
이상적으로 하위 도메인과 바운디드 컨텍스트가 일대일 관계를 가지면 좋겠지만 현실적으로 하나의 하위 도메인에 두개의 바운디드 컨텍스트가 있을 수 있고 두 개의 하위 두메인이 하나의 바운디드 컨텍스트를 구현하기도 한다.












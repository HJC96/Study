SOLID 원칙을 테스트 코드 도입하며 이해

SRP: 단일 책임 원칙. 만약 UserService라는 서비스 안에, 회원가입, 인증메일 발송. 이 두가지의 메서드가 있다고 해보자. 회원 가입 테스트 코드를 작성하려고, UserService 객체를 모킹했을때, 코드는 필요하지 않은 EmailSender까지 구현을 요구하게 된다. (왜냐하면 UserService 객체 안에 이메일 발송이 함께 있으니…) 이게테스트 코드가 보내는 신호다. 단일 책임을 지키고 있지 않다는 것이다. 이때, MemberRegister와 AuthenticationService로 분리하자.

OCP: 개방에는 열려있고, 수정에는 닫혀있는 것이다. 객체지향원칙에 따라 잘 설계했다면 해당 원칙은 지켜지게 된다. 이를테면 DB 접근 구현체를 갈아끼우는 것(h2 → jpa) 등이 있다.

LIP: 리스코프 치환원칙. 

직사각형이 있고 정사각형 클래스가 있다고 해보자. 논리적으로는 정사각형이면 직사각형이기 때문에 직사각형 클래스를 상속하여 정사각형을 만들 수가 있다. 하지만 만약 넓이를 구하는 메소드를 테스트 하고자 할때, 직사각형 클래스 같은 경우는 너비와 높이가 다를 수 있고, 정사각형은 다를 수 없다. 따라서 초기 높이, 너비 10, 10 에서 너비만 5로 바꾼후 넓이를 구하는 테스트를 했을때, 두 가지는 결과가 다를 것이고 리스코프 치환 원칙을 위반했다는 것을 알 수 있게 된다.

이럴 경우는 Shape라는 클래스를 두고 square와 rectangle이 그 클래스를 상속받아서 구현하면 된다. 

ISP: 인터페이스 분리 원칙. 

EmailSender가 있다고 하자. EmailSender에 웰컴 이메일, 탈퇴시 발송 이메일 이런식으로 많은 인터페이스들이 몰려 있을 수 있다. 내가 EmailSender만 테스트 하고 싶은데, 탈퇴했을 경우 메서드도 구현해야 하는 일이 생긴다. 이게 인터페이스가 분리되지 않았다는 거고, 차라리 하나의 인터페이스에 하나의 메서드를 만들어 다중 구현 하는 형식으로 구현할 수 있다.

DIP: 의존성 역전 원칙

로그인시 현재 시간을 기록하는 로직이 있다고 했을때, 그 로직이 메서드 내부에만 있다면 테스트가 불가능하다. 이때 메서드의 패러미터로 ClockHolder라는 것을 주입받아서 사용하면 그것은 테스트가 가능해진다.

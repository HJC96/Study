
Q1) Spring Boot 테스트 전략 표 검토 및 개선
문제점:

Unit Test에서 Mock 사용법이 부정확
Integration Test에서 "실제 DB" 표현이 애매
E2E Test 범위 정의가 불명확

개선된 테스트 전략:

Unit: 도메인, Service, Controller, Repository 각각 독립적 테스트
Integration: 컴포넌트 간 통합 + 테스트 DB 사용
E2E: 전체 시스템 플로우 + 실제 환경 유사하게 구성


Q2) Repository Test vs Database Integration Test
@DataJpaTest (Repository Test):

JPA 레이어만 테스트
기본적으로 H2 인메모리 DB 사용
커스텀 쿼리 검증 목적

Database Integration Test:

Service → Repository → DB 전체 플로우
TestContainers로 실제 DB(MySQL, PostgreSQL 등) 사용
DB 특화 기능 테스트


Q3) Controller 테스트(@WebMvcTest)는 실제 통합테스트(@SpringBootTest)에 포함되는거 아닌가? 왜 굳이 테스트를 해야하지?
@WebMvcTest의 독립적 가치:

@Valid 검증이라던지, 에러 Response 확인을 빠르게 할 수 있다는 장점
HTTP 레이어만 격리해서 테스트 (빠른 피드백)
직렬화/역직렬화, 상태 코드 검증에 특화
@SpringBootTest보다 가볍고 빠름


Q4) E2E 테스트 도구 선택 - Cypress vs Spring Boot
프론트엔드(React) + 백엔드(Spring Boot) 환경:

Cypress: 브라우저 사용자 관점의 UI E2E
@SpringBootTest: API 클라이언트 관점의 API E2E

백엔드 Only 환경:

@SpringBootTest가 E2E 테스트 역할


Q5) 풀스택 환경에서 E2E 테스트 전략
두 가지 E2E가 모두 필요:

Frontend E2E (Cypress): 사용자 브라우저 경험
Backend E2E (@SpringBootTest): API 서버 비즈니스 플로우

이유:

다양한 클라이언트 (웹, 모바일, 외부 시스템)
복잡한 비즈니스 로직은 Cypress로 테스트하기 어려움
동시성, 성능, 에러 케이스 등은 API 테스트가 유리


Q6) Backend Only에서 E2E vs Integration Test 구분
실제로는 경계가 모호함:

많은 팀에서 굳이 구분하지 않고 "통합 테스트"로 통칭
구분하는 경우: 테스트 범위와 목적에 따라 느슨하게 분류

현실적 접근:

Integration: 특정 컴포넌트 조합 테스트
E2E: 전체 비즈니스 플로우 테스트


Q7) 테스트 범위 - E2E가 Integration보다 좁은 범위인가?
범위는 E2E가 더 넓음:
Unit Test < Integration Test < E2E Test

Unit: 개별 클래스/메서드
Integration: 특정 컴포넌트들의 통합
E2E: 시스템 전체를 관통하는 가장 넓은 범위


Q8) 사용자 시나리오를 API로 테스트하면 E2E인가 Integration인가?
명확히 E2E 테스트:

핵심은 "사용자 시나리오" 여부
UI 포함 여부가 아닌 "전체 비즈니스 플로우" 검증이 기준
API로 사용자 여정을 재현하는 것도 E2E


Q9) 사용자 시나리오에는 웹이 포함되어야 하는 것 아닌가?
사용자의 정의에 따라 달라짐:

브라우저 사용자 → UI E2E (Cypress)
API 클라이언트(모바일, 다른 서버) → API E2E (@SpringBootTest)

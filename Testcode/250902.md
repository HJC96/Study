스프링 통합 테스트에서 데이터 격리하기

테스트 코드를 도입하다 보면 가장 먼저 부딪히는 문제가 있습니다. 테스트 간 데이터가 섞이는 것이에요. 하나의 테스트에서 저장한 데이터가 다른 테스트 결과에 영향을 주면서, 어떤 때는 통과하고 어떤 때는 실패하는 상황이 생깁니다. 저도 처음엔 왜 이런 현상이 생기는지 몰라서 꽤 당황했어요.

이번 글에서는 제가 겪었던 문제와, 서치하면서 정리한 스프링 테스트 데이터 격리 방법들을 공유하려고 합니다.

⸻

왜 데이터가 침범할까?

스프링 통합 테스트는 보통 하나의 애플리케이션 컨텍스트와 데이터베이스를 공유합니다. 그래서 한 테스트에서 insert한 데이터가 다른 테스트 실행 시 그대로 남아있는 경우가 많습니다. 결국 테스트 결과가 순서나 실행 방식에 따라 달라지는 거죠. 신뢰할 수 없는 테스트가 되어버립니다.

여기에 더해, H2 같은 인메모리 DB를 사용할 때는 또 다른 문제가 있었습니다. 저는 hibernate.hbm2ddl.auto=create-drop 설정을 사용했는데, 테이블을 비워도 시퀀스 값이 어떤 때는 유지되고, 어떤 때는 초기화되는 현상을 겪었어요. 알고 보니 DELETE FROM을 사용할 때는 시퀀스가 유지되고, TRUNCATE TABLE을 사용할 때는 보통 초기화가 되는데, H2의 모드나 제약 조건 상태에 따라 결과가 달라지더라고요. 운영 DB와는 다르게 동작하다 보니, 테스트에서만 애매한 문제가 발생했습니다.

⸻

해결 방법들

1. @Transactional + @Rollback

스프링 테스트에서 가장 기본적으로 쓰는 방법이에요. 테스트 메서드나 클래스에 @Transactional을 붙이면, 테스트 실행이 끝날 때 자동으로 롤백됩니다. DB 상태가 원래대로 돌아가니 다음 테스트에 영향을 주지 않아요.

@SpringBootTest
@Transactional
class UserServiceTest {

    @Autowired
    private UserRepository userRepository;

    @Test
    void testCreateUser() {
        userRepository.save(new User("alice"));
        // 검증 로직...
        // 테스트가 끝나면 자동으로 롤백
    }
}

다만 주의할 점도 있어요. E2E 테스트처럼 실제 HTTP 요청을 보내는 경우에는 트랜잭션이 다른 스레드에서 실행되기 때문에, 롤백이 제대로 적용되지 않을 수 있습니다.

⸻

2. @DirtiesContext

테스트가 끝날 때 애플리케이션 컨텍스트 자체를 갈아엎는 방법입니다. 말 그대로 이전 테스트 흔적이 전혀 남지 않아요. 완벽한 격리를 보장하죠.

@SpringBootTest
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)
class UserRepositoryTest {
    // 각 테스트 메소드 이후 컨텍스트를 새로 생성
}

문제는 속도입니다. 컨텍스트를 계속 새로 띄우다 보니 실행 시간이 확 늘어납니다. 저도 몇 번 써봤는데, 정말 필요한 경우가 아니면 잘 안 쓰게 되더라고요.

⸻

3. @Sql

테스트 전후로 SQL 스크립트를 실행하는 방식입니다. 예를 들어 각 테스트 전에 테이블을 TRUNCATE 하도록 설정할 수 있습니다.

@SpringBootTest
@Sql(scripts = "/cleanup.sql", executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)
class OrderServiceTest {
    // cleanup.sql 안에서 truncate나 delete문 실행
}

테이블이 많아지면 관리가 번거롭지만, 단순한 초기화에는 꽤 효과적입니다.

⸻

4. 커스텀 DB 초기화

저는 개인적으로 이 방식을 제일 많이 씁니다. 테스트 실행 전에 엔티티 메타데이터를 읽어서 모든 테이블을 TRUNCATE 하는 유틸 클래스를 하나 두는 거예요.

@TestComponent
class DatabaseCleanup implements InitializingBean {
    @PersistenceContext
    private EntityManager em;
    private List<String> tableNames;

    @Override
    public void afterPropertiesSet() {
        tableNames = em.getMetamodel().getEntities().stream()
            .filter(e -> e.getJavaType().getAnnotation(Entity.class) != null)
            .map(e -> e.getName())
            .toList();
    }

    @Transactional
    public void execute() {
        em.createNativeQuery("SET REFERENTIAL_INTEGRITY FALSE").executeUpdate();
        for (String table : tableNames) {
            em.createNativeQuery("TRUNCATE TABLE " + table).executeUpdate();
        }
        em.createNativeQuery("SET REFERENTIAL_INTEGRITY TRUE").executeUpdate();
    }
}

테스트 시작 전에 databaseCleanup.execute()만 호출해주면 항상 깨끗한 상태에서 시작할 수 있습니다.

⸻

DB 전략: H2 vs Testcontainers

H2 인메모리 DB
	•	장점: 빠르고 설정 간단
	•	단점: 운영 DB(MySQL, PostgreSQL 등)와 동작 차이가 있을 수 있음

저는 H2를 쓸 때 시퀀스가 유지되기도 하고 초기화되기도 하는 애매한 경험을 했습니다. 이 때문에 테스트 결과가 일정하지 않을 수 있고, 실제 운영 DB와의 차이 때문에 놓치는 케이스가 발생할 수 있습니다.

Testcontainers
	•	장점: 운영 환경과 동일한 DB 사용 가능
	•	단점: 실행 속도 느림, Docker 필요

보통은 로컬에서는 H2로 빠르게 돌리고, CI에서는 Testcontainers를 써서 실제 DB 환경에서 한번 더 돌려보는 식으로 조합하면 괜찮습니다.

⸻

정리

테스트 신뢰성을 확보하려면 반드시 데이터 격리가 필요합니다. 상황에 따라 다르지만, 저는 이렇게 정리했어요:
	•	단위/슬라이스 테스트 → @Transactional 기반 롤백
	•	통합 테스트 → DB 초기화 유틸 or @Sql
	•	E2E 테스트 → 경우에 따라 @DirtiesContext나 Testcontainers 활용

결국 중요한 건 테스트가 독립적으로 실행될 수 있어야 한다는 것이에요. 그래야 테스트를 믿고 리팩토링할 수 있거든요.

다음은 전체 강의 내용을 통합하여 하나의 자료로 정리한 최종 버전이에요. 계층적 구조(1-1, 1-2, …)로 정리해 암기·회고·말하기 연습 모두에 활용하기 좋게 만들었습니다.

**테스트와 설계 개선을 위한 실무 가이드 (강의 통합 정리)**

**1. 테스트 범위와 전략**

**1-1. 테스트 범위에 대한 강사의 생각**

•	테스트 범위는 사람·조직·회사마다 다르며 정답은 없음

•	**중점 테스트 영역**: 서비스 구현체, 도메인 로직

•	**덜 테스트하는 영역**: 컨트롤러, JPA 레포지토리 구현체

(스프링과 Hibernate/JPA 팀에서 이미 충분히 검증됨)

•	단순 CRUD 중심 서비스는 테스트에 과도한 시간 투자 불필요

**1-2. 테스트 크기 이해**

•	**소형 테스트 (Small Test)**: 외부 의존성 없는 순수 단위 테스트 (빠름)

•	**중형 테스트 (Medium Test)**: H2 등 인메모리 DB 사용한 통합 테스트

•	**대형 테스트 (Large Test)**: 실제 인프라 (실제 DB, 외부 API) 연동

**2. 테스트 격리와 신뢰성 확보**

**2-1. 문제 상황: 공유 상태로 인한 테스트 실패**

•	개별 실행 시 성공하지만, 전체 실행 시 실패하는 **비결정적 테스트**

•	원인: 테스트 메소드들이 **하나의 H2 DB**를 공유 → 이전 테스트의 데이터가 다음 테스트를 깨뜨림

**2-2. 해결책: @Sql과 @SqlGroup**

•	**@Sql**: 각 테스트 실행 전 필요한 SQL 파일 실행 → 테스트 데이터 명시적 준비

•	**@SqlGroup**:

•	BEFORE_TEST_METHOD: 데이터 준비 SQL 실행

•	AFTER_TEST_METHOD: 데이터 정리 SQL 실행 (DELETE/TRUNCATE)

•	→ **준비 → 실행 → 정리 사이클**로 모든 테스트 환경을 독립적·결정적으로 유지

**3. 외부 의존성 단절 (Mock 활용)**

**3-1. 문제 상황**

•	User 생성 시 JavaMailSender 호출 → 테스트 환경에서 SMTP 서버 없음 → 테스트 실패

•	테스트의 관심사는 “사용자 생성 로직”, 이메일 발송이 아님

**3-2. 해결책: @MockBean + Mockito**

•	**@MockBean**: 테스트 시 실제 Bean 대신 가짜(Mock) 객체 사용

•	**Mockito 시나리오 작성**:

```
doNothing().when(javaMailSender).send(any(SimpleMailMessage.class));
```

→ 어떤 메시지를 보내도 아무 동작하지 않음

•	테스트는 오직 비즈니스 로직 검증에 집중 → **관심사 분리 원칙** 실현

**4. 예측 불가능성 다루기**

**4-1. 문제 상황**

•	UUID.randomUUID() → 매번 다른 값

•	LocalDateTime.now() → 매번 다른 시간

**4-2. 해결책(추후 과제)**

•	**Clock 인터페이스** 주입 방식으로 리팩토링 → 테스트에서 고정된 시간 사용 가능

•	현재 강의에서는 // TODO 남기고 넘어감 → 실무에서 마주칠 고민거리 제시

**5. 컨트롤러 테스트 (MockMvc)**

**5-1. 컨트롤러 테스트 필요성**

•	요청-응답 매핑, 파라미터 처리, 상태 코드, 응답 본문 검증

•	실제 서버 기동은 느림 → MockMvc로 서블릿 컨테이너 모의

**5-2. MockMvc 테스트 과정**

1.	**설정**: @SpringBootTest, @AutoConfigureMockMvc, MockMvc 주입

2.	**요청 시뮬레이션**: mockMvc.perform(get(...)), .param(), .content()

3.	**응답 검증**:

•	status().isOk(), status().isNotFound()

•	jsonPath("$.id").value(1)

•	content().string("...")

**6. 도메인과 설계 개선**

**6-1. 문제 인식: 레이어드 아키텍처 한계**

•	DB 주도 설계 → 비즈니스 로직이 데이터베이스에 강하게 결합

•	서비스에 비즈니스 로직 집중 → **Anemic Domain + Fat Service**

•	순차적 개발 강제 → 병렬 개발 어려움

•	테스트는 항상 DB 의존적 → 느린 중형 테스트 양산

**6-2. 해결책: DIP(의존성 역전 원칙) 적용**

•	Controller, Service, Repository → **인터페이스 의존**

•	구현체(ServiceImpl, RepositoryImpl)는 외부에서 주입

•	**효과**:

1.	도메인 레이어 독립 → DB 없이 소형 테스트 가능

2.	Service/Controller 테스트 시 Fake Repository, Fake Service로 대체 가능

3.	인프라 레이어 분리 → 외부 기술 변경 시 비즈니스 로직 영향 최소화

**6-3. 패키지 구조 개선**

•	도메인을 최상위 패키지로 이동 → 서비스 목적 명확

•	repository → infrastructure 로 변경 (외부연동 구현체 포함)

**6-4. 도메인 객체와 엔티티 분리**

•	JPA Entity와 도메인 객체 분리

•	도메인에 비즈니스 로직 집중, setter 제거 → 더 강력한 테스트 가능

**6-5. CQRS 적용**

•	**Command**: 상태 변경 (void)

•	**Query**: 상태 조회 (변경 없음)

•	명령과 질의 분리 → 가독성과 유지보수성 향상

**7. 남은 과제와 테스트의 시그널**

•	@SpringBootTest 의 느린 속도

•	H2와 운영 DB 불일치 가능성

•	UUID, 시간 문제 여전히 미해결

•	설계 개선 필요성 (비대한 컨트롤러, private 메소드 테스트 욕구)

![image.png](attachment:099177c7-17de-4723-95b6-0c41fb238570:image.png)

![image.png](attachment:b91cfa7a-2306-4135-9b14-bb37556abeb5:image.png)

![image.png](attachment:00b672a7-8878-4eaa-9531-d407384223ae:image.png)

![image.png](attachment:839771ab-8c5e-433e-a53c-ad3eb86db534:image.png)

![image.png](attachment:836ee6a4-448b-437c-9d17-904198dd7bed:image.png)

![image.png](attachment:f8c71c7b-a191-4e08-90fc-27f5465de247:image.png)

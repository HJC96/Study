### 1\. `VARCHAR` vs `TEXT`: 기본 차이점

두 타입 모두 최대 **64KB**까지 저장 가능한 문자열 타입이지만, 동작 방식에 중요한 차이가 있음.

  * **인덱스 생성:**
      * `VARCHAR`: 전체 길이에 대해 인덱스 생성 가능 (길이 제한 내에서).
      * `TEXT`: 반드시 \*\*Prefix 길이(앞부분 몇 글자)\*\*를 지정해야만 인덱스 생성 가능.
  * **Default 값 지정:**
      * `VARCHAR`: 리터럴로 지정 가능.
      * `TEXT`: 리터럴 지정 불가, \*\*표현식(Expression)\*\*으로만 지정 가능 (MySQL 버전에 따라 상이할 수 있으나 영상 기준).

### 2\. 메모리 처리 방식과 성능 (핵심)

MySQL 엔진이 데이터를 읽을 때 메모리 버퍼를 할당하는 방식의 차이가 성능을 결정함.

  * **메모리 할당 메커니즘:**
      * MySQL은 레코드를 읽을 때 \*\*'최대 Row Size'\*\*만큼의 메모리 버퍼를 미리 할당하고 재사용함.
  * **`VARCHAR`의 특징:**
      * 이 **미리 할당된 버퍼**에 포함됨.
      * **장점:** 메모리 할당/해제 오버헤드가 없어 **처리가 빠름.**
      * **단점:** `VARCHAR(255)` 등으로 크게 잡으면, 실제 데이터가 작아도 메모리를 많이 잡아먹음 (메모리 효율 저하).
  * **`TEXT`의 특징:**
      * 미리 할당된 버퍼를 쓰지 않고, **필요할 때마다 별도로 메모리를 할당/해제**함.
      * **장점:** 메인 버퍼(Row Size)를 차지하지 않아 Row Size Limit 회피 가능.
      * **단점:** 메모리 할당 오버헤드 발생.

### 3\. Off-Page (Overflow Page) 저장 구조

  * **정의:** 레코드 크기가 데이터 페이지(기본 16KB)의 절반을 넘어가면, 긴 컬럼 데이터를 \*\*외부 페이지(Off-Page)\*\*로 따로 저장하고 본문에는 **20바이트 포인터**만 남기는 방식.
  * **발생 조건:** `VARCHAR`나 `TEXT`에 매우 큰 데이터가 저장될 때.
  * **성능 영향:** 해당 컬럼을 조회할 때 추가적인 디스크 I/O(외부 페이지 읽기)가 발생하여 성능이 저하됨.

### 4\. 최적의 타입 선택 기준

| 상황 | 추천 타입 | 이유 |
| :--- | :--- | :--- |
| **길이가 짧고(상대적), <br>조회가 빈번함** | **`VARCHAR`** | 메모리 버퍼를 재사용하여 오버헤드를 줄이고 빠른 처리 가능. |
| **길이가 매우 길고,<br>가끔 조회됨** | **`TEXT`** | 메인 Row Size 제한(64KB 등)을 피하고, 불필요한 메모리 사전 할당 방지. |
| **테이블에 컬럼이 이미 많음** | **`TEXT`** | `VARCHAR`를 추가하면 Row Size Limit에 걸릴 수 있으므로 `TEXT`로 분리. |

### 5\. 쿼리 작성 및 스키마 설계 팁

  * **`VARCHAR` 길이 최적화:** `VARCHAR(255)`처럼 관습적으로 크게 잡지 말고, **실제 필요한 길이만큼만** 선언할 것 (메모리 효율 때문).
  * **`SELECT *` 지양:**
      * Off-Page로 저장된 `TEXT`나 큰 `VARCHAR` 컬럼을 불필요하게 조회하면 성능이 급격히 저하됨 (영상 예시: 4배 차이).
      * 필요한 컬럼만 명시하면 **커버링 인덱스(Covering Index)** 활용 가능성이 높아짐.

**요약 핵심:**
빈번하게 조회되는 적당한 길이의 데이터는 \*\*`VARCHAR`\*\*가 성능상 유리합니다. 단, `VARCHAR` 길이를 너무 크게 잡으면 메모리 효율이 떨어지므로 **필요한 만큼만** 잡아야 하며, 대용량 컬럼은 꼭 필요할 때만 `SELECT` 해야 합니다.

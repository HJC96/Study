### 1. `LATERAL DERIVED TABLE`이란?
* **기존 Derived Table의 한계:** `FROM` 절의 서브쿼리(Derived Table)는 선행 테이블의 컬럼을 참조할 수 없었음.
* **`LATERAL`의 등장:** Derived Table 앞에 `LATERAL` 키워드를 붙이면, **선행 테이블(먼저 읽은 테이블)의 컬럼 값을 참조**하여 동적으로 결과 집합을 생성할 수 있음.
* **동작 원리:** 선행 테이블의 각 레코드마다 `LATERAL` 서브쿼리가 반복 실행되는 형태 (마치 `FOREACH` 루프와 유사). 실행 계획에서는 `DEPENDENT DERIVED`로 표시됨.

### 2. 활용 사례 1: 종속 서브쿼리 최적화 (다중 값 반환)
* **문제 상황:** 부서별로 '가장 먼저 입사한 직원'의 **입사일과 이름**을 동시에 조회하고 싶을 때.
    * `SELECT` 절의 서브쿼리는 하나의 컬럼만 반환 가능하므로, 입사일용 쿼리와 이름용 쿼리를 각각 작성해야 하는 비효율 발생.
* **`LATERAL` 활용:**
    * `FROM` 절에서 `LATERAL`을 사용하여 입사일과 이름을 한 번의 서브쿼리로 조회.
    * 쿼리가 간결해지고 중복 실행이 제거되어 성능 향상.

### 3. 활용 사례 2: 중복 연산 제거 (계산된 값 재사용)
* **문제 상황:** 일별 매출 데이터에서 '총 매출', '예상 매출' 등을 계산한 뒤, 이 값들을 이용해 또 다른 지표(이익률 등)를 계산해야 할 때.
    * `SELECT` 절에서는 같은 레벨의 별칭(Alias)을 참조할 수 없어 연산식을 중복 작성해야 함.
* **`LATERAL` 활용:**
    * 먼저 계산된 값을 `LATERAL` 테이블로 정의하고, 그 다음 `LATERAL` 테이블에서 앞선 계산 결과를 참조하여 연쇄적으로 계산.
    * 가독성이 좋아지고 로직 중복이 제거됨.

### 4. 활용 사례 3: Top-N 쿼리 최적화 (Groupwise Limit)
* **문제 상황:** 카테고리별로 조회수가 가장 높은 뉴스 3개씩만 뽑고 싶을 때.
    * 일반적인 방식: 전체 데이터를 조인하고 윈도우 함수(`RANK()`)로 정렬한 뒤 필터링 $\rightarrow$ **전체 데이터 스캔 및 정렬 발생 (느림).**
* **`LATERAL` 활용:**
    * 카테고리 테이블을 먼저 읽고(`Categories`), 각 카테고리 ID를 `LATERAL` 서브쿼리로 넘겨줌.
    * 서브쿼리 내부에서 해당 카테고리의 뉴스만 인덱스를 타서 정렬하고 `LIMIT 3`으로 끊음.
    * **효과:** 필요한 데이터만 쏙쏙 뽑아오므로 성능이 획기적으로 개선됨 (영상 예시: 2.88초 $\rightarrow$ 0.08초).

**요약 핵심:**
`LATERAL DERIVED TABLE`은 `JOIN`과 유사해 보이지만, **선행 테이블의 데이터를 참조하여 서브쿼리를 동적으로 실행**할 수 있다는 강력한 특징이 있습니다. 이를 통해 **복잡한 집계, 선행 데이터 기반 분석(Funnel 등), 그룹별 Top-N 조회** 등에서 쿼리를 단순화하고 성능을 극대화할 수 있습니다.

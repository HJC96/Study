### 1. Generated Column (생성된 컬럼)
* **개념:** 사용자가 값을 직접 입력하는 것이 아니라, 정의된 **표현식(Expression)**에 의해 자동으로 값이 계산되는 컬럼. (예: `col1 + col2`)
* **종류:**
    1.  **Virtual (가상):**
        * 디스크에 값을 저장하지 않고 읽을 때마다 계산함.
        * `INSERT`/`UPDATE` 시 오버헤드가 적지만 읽기 시 계산 비용 발생.
        * 인덱스 생성 가능 (이 경우 인덱스에는 값이 저장됨).
        * 기본값 (타입 미지정 시).
    2.  **Stored (저장):**
        * 계산된 값을 실제로 디스크에 저장함.
        * `INSERT`/`UPDATE` 시 계산 비용과 저장 공간이 들지만, 읽기 시 빠름.
        * Primary Key로 사용 가능.
* **특징:**
    * 값 직접 입력/수정 불가 (`DEFAULT` 키워드만 허용).
    * DDL(`ALTER TABLE`) 시 `Virtual` 컬럼은 `INPLACE` 알고리즘으로 빠르게 추가 가능 (데이터 복사 없음).

### 2. Function-based Index (함수 기반 인덱스)
* **개념:** 컬럼의 값을 변형한 **표현식(함수, 수식 등)의 결과**를 인덱싱하는 기능 (MySQL 8.0.13+).
* **동작 원리:** 내부적으로 해당 표현식을 가진 **Virtual Generated Column(가상 컬럼)**을 생성하고, 그 컬럼에 인덱스를 거는 방식으로 동작함. (가상 컬럼은 숨겨져 있음).
* **활용 사례:**
    * **부분 검색:** 이메일 도메인만 인덱싱 (`SUBSTRING_INDEX`).
    * **대소문자 무시:** 소문자로 변환하여 인덱싱 (`LOWER`).
    * **JSON 검색:** JSON 내부 특정 필드 인덱싱.
    * **수식 검색:** `(col1 + col2)` 결과 인덱싱.

### 3. 함수 기반 인덱스 사용 시 주의사항
* **쿼리 작성:** 인덱스 생성 시 사용한 **표현식과 완전히 동일한 형태**로 `WHERE` 절을 작성해야 인덱스를 탐.
    * 인덱스: `(col1 + 1)` $\rightarrow$ 쿼리: `WHERE col1 + 1 = 10` (O)
    * 쿼리: `WHERE 1 + col1 = 10` (X - 순서만 바뀌어도 못 탐)
* **데이터 타입:** 표현식의 결과 타입과 **동일한 타입의 상수**로 비교해야 함.
    * 예: 표현식 결과가 `INT`인데 문자열 `'10'`과 비교하면 인덱스 못 탈 수 있음.
* **제약 사항:**
    * 비결정적 함수(Non-deterministic, 예: `NOW()`, `RAND()`) 사용 불가.
    * Primary Key에는 함수 기반 인덱스 적용 불가 (가상 컬럼 기반이므로).

**요약 핵심:**
**Generated Column**은 데이터의 가공된 형태를 컬럼처럼 다룰 수 있게 해주며, 이를 활용한 **함수 기반 인덱스**는 컬럼 값을 변형해야 하는 검색 조건(대소문자 무시, 수식 등)에서도 인덱스를 탈 수 있게 해주는 강력한 기능입니다. 단, 쿼리 작성 시 **표현식을 토씨 하나 안 틀리고 똑같이** 써야 인덱스가 적용된다는 점을 명심해야 합니다.

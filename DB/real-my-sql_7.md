### 1. 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)
* **개념:** `SELECT` 시 테이블이나 레코드에 락을 걸지 않고도, 다른 트랜잭션이 변경 중인 데이터를 읽을 수 있는 기능.
* **동작 원리:** 변경 중인 데이터 대신 **Undo 영역(백업 공간)**에 있는 변경 전 데이터를 읽음.
* **장점:** 읽기 작업이 쓰기 작업(Lock)을 방해하지 않아 동시성 처리가 뛰어남.
* **주의:** 격리 수준(Isolation Level)에 따라 읽는 데이터 버전이 다름.
    * `READ COMMITTED`: 가장 최근 커밋된 데이터 반환.
    * `REPEATABLE READ`: 트랜잭션 시작 시점의 데이터 반환 (반복 읽기 시 결과 동일).

### 2. `SELECT ... FOR UPDATE` & `FOR SHARE`
* **목적:** 데이터를 읽은 후 변경(Update)할 예정일 때, 다른 트랜잭션이 중간에 데이터를 바꾸지 못하도록 미리 락을 거는 것.
* **동작:**
    * `FOR UPDATE`: **Exclusive Lock (쓰기 잠금)** 획득. 다른 트랜잭션의 읽기/쓰기 모두 차단 (단, 단순 SELECT는 가능).
    * `FOR SHARE`: **Shared Lock (읽기 잠금)** 획득. 다른 트랜잭션의 쓰기는 차단하지만 읽기는 허용.
* **특징:** 격리 수준과 상관없이 **항상 최신 커밋된 데이터**를 읽어옴.
* **주의사항 (Lock Upgrade & Deadlock):**
    * `FOR SHARE`로 읽은 뒤 `UPDATE`를 하면, 공유 잠금을 배타적 잠금으로 업그레이드해야 함. 이 과정에서 다른 트랜잭션과 맞물려 **데드락(Deadlock)** 발생 가능성이 높음.
    * 따라서 읽은 후 변경할 거라면 처음부터 `FOR UPDATE`를 쓰는 것이 안전함.

### 3. JPA의 낙관적 락(Optimistic Lock) vs 비관적 락(Pessimistic Lock)

#### **1) Optimistic Lock (낙관적 락)**
* **가정:** 충돌이 거의 없을 것이라고 가정.
* **구현:**
    * DB의 락 기능이 아닌, 테이블의 **버전(Version) 컬럼**을 이용한 애플리케이션 레벨의 처리.
    * `UPDATE ... WHERE id=? AND version=?` 쿼리 실행.
    * 다른 트랜잭션이 먼저 수정해서 버전이 바뀌면, `Affected Row = 0`이 되어 예외(`OptimisticLockingFailureException`) 발생.
* **장점:** 락을 걸지 않아 동시성이 좋음.
* **단점:** 충돌 발생 시 예외 처리 및 재시도 로직이 필요하며, 충돌이 잦으면 성능 저하.

#### **2) Pessimistic Lock (비관적 락)**
* **가정:** 충돌이 빈번할 것이라고 가정.
* **구현:**
    * DB의 **`SELECT ... FOR UPDATE`** 기능을 사용하여 물리적인 락을 검.
    * 트랜잭션 시작 시점에 락을 획득하고 끝날 때까지 유지.
* **장점:** 데이터 정합성을 강력하게 보장하며, 충돌 발생 시 대기하므로 예외 처리가 단순함.
* **단점:** 락 대기 시간으로 인해 동시성 처리가 저하될 수 있음.

**요약 핵심:**
일반적인 조회는 **잠금 없는 읽기**로 빠르지만, 데이터 변경을 전제로 한 조회는 **`SELECT FOR UPDATE`**를 사용하여 정합성을 지켜야 합니다. JPA 사용 시 충돌 가능성이 낮다면 **Optimistic Lock**을, 높다면 **Pessimistic Lock**을 선택하는 전략이 필요합니다.

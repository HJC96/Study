### 1. Prepared Statement 개요
* **정의:** SQL 쿼리의 구조를 미리 컴파일(Parsing)해두고, 실행 시에는 변수(`?`)만 바인딩하여 반복 실행하는 방식.
* **일반적인 장점:**
    1.  **SQL Injection 방지:** 값 바인딩 처리로 보안성 강화.
    2.  **파싱 비용 절감:** 최초 1회만 파싱하고 이후에는 캐시된 실행 계획(또는 Parse Tree)을 재사용하여 성능 향상.

### 2. MySQL에서의 Prepared Statement 특징 (주의사항)

#### **① Client-side vs Server-side**
* **Client-side:** MySQL 서버가 기능을 제공하기 전, JDBC 드라이버 차원에서 에뮬레이션하던 방식 (단순 텍스트 치환).
* **Server-side:** MySQL 서버가 실제로 쿼리를 파싱하고 캐시하는 방식.
    * *주의:* MySQL JDBC 드라이버(`Connector/J`)의 기본 설정은 `useServerPrepStmts=false`임. 즉, 별도 설정을 하지 않으면 **Client-side 방식(에뮬레이션)으로 동작**하여 서버 측 성능 이점은 없음 (단, SQL Injection 방지 효과는 있음).

#### **② Connection 단위 캐싱**
* **문제점:** MySQL의 Prepared Statement는 **커넥션(Connection) 단위로만 캐시**됨.
    * 즉, A 커넥션에서 파싱한 쿼리는 B 커넥션에서 재사용 불가능.
    * 커넥션 풀을 사용하여 커넥션이 100개라면, 동일한 쿼리라도 각 커넥션마다 따로 파싱되어 총 **100개의 Prepared Statement 객체**가 메모리에 생성됨.
* **결과:**
    * **메모리 사용량 증가:** 커넥션 수가 많을수록 메모리 낭비 심화.
    * **파싱 효율 저하:** 커넥션 수명 주기가 짧거나(매번 새로 맺는 경우), 쿼리 패턴이 너무 다양하면 캐시 효율이 떨어짐.

#### **③ 실행 계획 캐싱 미지원**
* Oracle 등 다른 DBMS와 달리, MySQL은 **Parse Tree(구문 분석 트리)까지만 캐시**하고, **실행 계획(Execution Plan)은 캐시하지 않음.**
    * 따라서 매 실행 시마다 최적화(Optimization) 과정은 여전히 수행됨.

### 3. 성능 최적화 가이드

#### **✅ 도움이 되는 경우**
* **복잡한 쿼리:** 파싱 비용 자체가 높은 복잡한 쿼리를 자주 실행할 때.
* **긴 커넥션 수명:** 커넥션 풀을 사용하여 커넥션을 오래 유지하고 재사용하는 환경.

#### **❌ 도움이 안 되거나 역효과가 나는 경우**
* **단순한 OLTP 쿼리:** MySQL은 단순 쿼리의 파싱 속도가 매우 빠르므로, Prepared Statement를 위한 통신 오버헤드(Prepare + Execute 2번 통신)가 더 클 수 있음.
* **짧은 커넥션 / 많은 커넥션:** 커넥션을 자주 맺고 끊거나, 커넥션 수가 너무 많으면 메모리 부족 이슈 발생 가능.
* **메모리 부족 환경:** 클라우드(RDS) 등 메모리가 제한적인 환경에서는 Prepared Statement 캐시 메모리가 부담이 되어, 차라리 그 메모리를 **InnoDB Buffer Pool**에 할당하는 것이 전체 성능에 더 유리할 수 있음.

**요약 핵심:**
MySQL에서 Server-side Prepared Statement를 쓴다고 무조건 성능이 빨라지는 것은 아닙니다. **커넥션 단위 캐싱**이라는 특성 때문에 메모리 사용량이 늘어날 수 있으며, 단순 쿼리 위주라면 오히려 **Client-side 방식(SQL Injection 방지 목적만 달성)**이 더 효율적일 수 있습니다. 프로젝트 환경(메모리, 커넥션 수, 쿼리 복잡도)을 고려하여 `useServerPrepStmts` 옵션 활성화 여부를 결정해야 합니다.

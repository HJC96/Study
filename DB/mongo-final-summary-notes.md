## MongoDB 시험 직전 최종 암기 노트 🚀

---

### **1. 인덱스와 쿼리 성능**

* **ESR 규칙 (가장 중요!)**: 복합 인덱스를 설계할 때 **`E`quality(동등)**, **`S`ort(정렬)**, **`R`ange(범위)** 순서를 지켜야 합니다. 이 순서로 인덱스를 만들어야 필터링과 정렬이 동시에 최적화됩니다.

* **'왼쪽 우선' 원칙**: 복합 인덱스는 **왼쪽 필드를 건너뛰고** 중간부터 사용할 수 없습니다. `find`, `sort`, 샤드 키 모두에 적용되는 대원칙입니다.

* **`find` vs. `sort` 순서**:
    * `find()`의 `{}` 안에서 필드 순서는 **상관없습니다.** `{a:1, b:1}`과 `{b:1, a:1}`는 MongoDB에게 동일한 요청입니다.
    * `sort()`에서는 필드 순서와 방향이 **매우 중요합니다.** `{a:1, b:1}`과 `{b:1, a:1}`는 완전히 다른 정렬입니다.

* **커버드 쿼리 (Covered Query)**: 쿼리에 필요한 모든 필드(필터, 프로젝션)가 **인덱스 안에 전부 포함**되어, 실제 문서를 읽지 않고 인덱스만으로 응답하는 가장 빠른 쿼리입니다. (`_id`는 명시적으로 제외해야 할 수 있습니다.)

---

### **2. 핵심 연산자 (`$`) 구분**

* **`$set` vs. 전체 교체**: 업데이트 시 **`$set` 같은 연산자가 없으면** 문서가 통째로 교체되어 기존 필드들이 사라집니다. (`_id`는 예외적으로 유지됩니다.)

* **`$elemMatch` (엄격한 AND)**: 배열 속 **'하나의 요소(객체)'**가 여러 조건을 **동시에** 만족할 때 사용합니다.
    * 예: `items: { $elemMatch: { quantity: { $gt: 2 }, discount: { $gte: 5 } } }`

* **느슨한 AND**: 배열 필드에 `$elemMatch` 없이 여러 조건을 걸면, 각 조건이 **서로 다른 요소**에서 만족되어도 문서가 찾아집니다.
    * 예: `{ "items.quantity": { $gt: 2 }, "items.discount": { $gte: 5 } }`

* **`$all` vs. `$in`**:
    * `$all`: 배열이 주어진 모든 값을 **다 포함**하는지 확인합니다. (AND 조건)
    * `$in`: 배열에 주어진 값 중 **하나라도 포함**되어 있는지 확인합니다. (OR 조건)

---

### **3. 데이터 모델링 패턴**

* **속성 패턴 (Attribute Pattern)**: 비슷한 필드가 많을 때 (예: `release_USA`, `release_France`) 하나의 배열로 묶어 관리합니다. 쿼리와 인덱싱이 쉬워집니다.
    * `releases: [ { location: "USA", date: ... }, { location: "France", date: ... } ]`

* **서브셋 패턴 (Subset Pattern)**: **자주 쓰는 데이터**와 **가끔 쓰는 데이터**를 분리하여 성능을 높입니다.
    * 예: 최신 주문은 고객 문서에 내장하고, 오래된 주문은 별도 컬렉션으로 분리.

---

### **4. 고급 개념**

* **레플리카 셋 & 읽기 설정**: 무거운 읽기 작업(애그리게이션)은 **세컨더리(Secondary) 노드**로 보내 프라이머리 부하를 줄일 수 있습니다 (`readPreference: "secondary"`). 프라이머리는 실시간 읽기/쓰기에 집중합니다.

* **샤드 키 vs. 인덱스**: **샤드 키**는 데이터를 '어디로 보낼지' 결정하는 분산 기준이며, **인덱스**는 '어떻게 빨리 찾을지'에 대한 도구입니다. 쿼리가 샤드 키의 왼쪽부터 포함해야 **타겟 쿼리**가 되어 효율적입니다.

* **Capped Collection vs. TTL**:
    * **Capped**: **크기 기반**. 컨베이어 벨트처럼 공간이 차면 가장 오래된 데이터가 자동으로 삭제됩니다.
    * **TTL**: **시간 기반**. 유통기한처럼 설정된 시간이 지나면 데이터가 자동으로 삭제됩니다. (Capped에서는 사용 불가)

* **`upsert: true`**: 업데이트할 문서가 없을 때, **`find`의 필터 조건**과 **`$set`의 업데이트 조건**을 **합쳐서** 새 문서를 삽입합니다.

* **원자성(Atomicity)**: MongoDB의 모든 쓰기 작업은 **문서(Document) 단위**에서 원자적입니다. 즉, 전부 성공하거나 전부 실패합니다. 여러 문서에 걸쳐 원자성이 필요할 땐 **트랜잭션**을 사용합니다.

### 1. `COUNT(*)` vs `SELECT *`: 성능에 대한 오해
* **오해:** `COUNT(*)`는 데이터 개수만 세니까 `SELECT *`보다 훨씬 빠를 것이다?
* **진실:**
    * 대부분의 경우 성능 차이가 거의 없음.
    * `SELECT *`는 보통 `LIMIT`와 함께 쓰여 일부만 읽지만, `COUNT(*)`는 `WHERE` 조건에 맞는 **모든 레코드**를 다 읽어야 함.
    * 따라서, **데이터가 많을수록 `COUNT(*)`가 훨씬 느리고 부하가 클 수 있음.**

### 2. `COUNT(*)` 성능 최적화 방법

#### **1) 커버링 인덱스 (Covering Index) 활용**
* **원리:** 데이터 파일(디스크)을 읽지 않고, **인덱스만 읽어서** 개수를 셈.
* **조건:** `WHERE` 절에 사용된 컬럼과 `COUNT` 대상 컬럼이 모두 하나의 인덱스에 포함되어야 함.
* **효과:** 디스크 I/O를 줄여 성능을 크게 향상시킬 수 있음.
* **한계:** 모든 쿼리를 커버링 인덱스로 처리하기엔 인덱스 관리 비용이 커질 수 있음.

#### **2) 쿼리 자체를 제거 (Best Practice)**
* UI/UX를 변경하여 전체 개수 조회가 필요 없게 만듦.
    * 예: '전체 페이지 수' 대신 '더보기' 버튼이나 '무한 스크롤' 방식 도입.

#### **3) 대략적인 건수 활용**
* **일부분만 조회:** 첫 페이지 로딩 시 `LIMIT 200` 정도로 조회하여, 200건 이상인지 미만인지만 확인.
* **통계 정보 활용 (`information_schema.tables`):** 정확한 개수가 필요 없다면 메타데이터의 예측치(`table_rows`)를 사용 (매우 빠름).

### 3. ORM과 `COUNT(DISTINCT)`의 함정
* **문제 상황:**
    * 일부 ORM(예: TypeORM)은 단순 개수 조회 시에도 불필요하게 `COUNT(DISTINCT PK)` 형태의 쿼리를 생성할 수 있음.
    * PK는 이미 유니크하므로 `DISTINCT`가 필요 없는데도 수행함.
* **성능 영향:**
    * `DISTINCT` 처리를 위해 **임시 테이블(Temporary Table)**을 생성하고, 정렬 및 중복 제거 작업을 수행해야 함.
    * 단순 `COUNT(*)` 대비 **2~3배 이상의 성능 저하** 발생 가능.
* **해결책:**
    * ORM이 생성하는 실제 쿼리(General Log 등 활용)를 반드시 확인.
    * 불필요한 `DISTINCT`나 서브쿼리가 포함된 경우, 직접 쿼리를 작성하거나 ORM 설정을 튜닝해야 함.

**요약 핵심:**
`COUNT(*)`는 결코 가벼운 작업이 아닙니다. **1) 꼭 필요한지 재검토하고, 2) 인덱스를 활용하거나 3) 대략적인 통계 값을 사용하는 방식**으로 튜닝해야 합니다. 특히 ORM 사용 시에는 **생성되는 쿼리가 최적화되어 있는지(불필요한 DISTINCT 여부)** 반드시 모니터링해야 합니다.

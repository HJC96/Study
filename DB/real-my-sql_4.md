### 1\. `LIMIT` & `OFFSET` 방식의 문제점

  * **동작 원리:** `LIMIT 10 OFFSET 1000`은 10건만 가져오는 것이 아니라, **1010건을 모두 읽은 뒤 앞의 1000건을 버리고 10건만 반환**합니다.
  * **성능 문제:** 페이지 번호가 뒤로 갈수록(Deep Pagination) 읽어야 할 데이터 양이 기하급수적으로 늘어나 DB 서버에 심각한 부하를 줍니다. (예: 500건씩 N번 조회 $\rightarrow$ 총 $1 \times 500 + 2 \times 500 + \dots + N \times 500$ 건 조회)

-----

### 2\. 페이징 쿼리 최적화: No-Offset 방식

기존의 비효율적인 `OFFSET`을 제거하고 성능을 최적화하는 두 가지 주요 접근법입니다.

#### **1) 범위 기반 방식 (Range-based Paging)**

  * **개념:** 특정 날짜나 숫자 범위를 기준으로 데이터를 나누어 조회합니다.
  * **특징:**
      * `LIMIT` 절을 사용하지 않고 `WHERE` 절에 범위 조건(`BETWEEN` 등)을 명시합니다.
      * 쿼리 형태가 단순하며 1회차와 N회차 쿼리가 동일합니다.
  * **사용처:** **배치(Batch) 작업**, 데이터 마이그레이션 등 전체 데이터를 순차적으로 처리해야 할 때 유용합니다.

#### **2) 데이터 개수 기반 방식 (Cursor-based Paging)**

  * **개념:** 직전에 조회한 마지막 데이터의 식별자(ID)나 정렬 기준 값을 '커서(Cursor)'로 사용하여, **그 다음 데이터부터 지정된 개수(`LIMIT`)만큼만** 조회합니다.
  * **특징:**
      * 1회차 쿼리와 N회차 쿼리의 형태가 다릅니다 (N회차에는 이전 마지막 데이터 조건 추가).
      * `OFFSET`을 쓰지 않아 페이지가 뒤로 가도 성능이 일정하게 유지됩니다.
  * **사용처:** **일반적인 웹/앱 서비스의 리스트 조회** (무한 스크롤 등).

-----

### 3\. 데이터 개수 기반 방식(Cursor-based) 상세 구현 전략

#### **Case A: 유니크한 식별자(PK)로만 정렬할 때**

  * **인덱스:** `(id)`
  * **쿼리:** `WHERE id > {last_id} ORDER BY id LIMIT 20`
  * **설명:** 가장 단순하고 효율적인 형태입니다.

#### **Case B: 다른 컬럼(날짜 등)으로 정렬할 때 (중복 값 존재 가능)**

  * **문제:** 정렬 기준 컬럼(`created_at`)에 중복 값이 있을 수 있으므로, 단순 비교(`>`)만으로는 데이터 누락이 발생할 수 있습니다.
  * **해결책:** 정렬 기준에 \*\*식별자(PK)\*\*를 포함하여 유니크한 순서를 보장해야 합니다.
      * **인덱스:** `(created_at, id)` - 복합 인덱스 필수.
      * **쿼리:**
        ```sql
        WHERE (created_at = {last_created_at} AND id > {last_id})
           OR (created_at > {last_created_at})
        ORDER BY created_at, id
        LIMIT 20
        ```
      * **설명:**
        1.  `created_at`이 같은 경우에는 `id`가 더 큰 데이터를 조회.
        2.  `created_at`이 더 큰 데이터를 조회.
        <!-- end list -->
          * *Tip:* 만약 `created_at`과 `id`의 정렬 순서가 동일하다면(둘 다 증가), 쿼리를 `created_at >= {last_created_at} AND id > {last_id}` 형태로 단순화할 수 있습니다.

**요약 핵심:**
대용량 서비스에서는 `OFFSET`을 사용하는 페이징을 피해야 합니다. 대신 \*\*마지막 조회 위치(Cursor)\*\*를 기억했다가 그 다음부터 읽는 **No-Offset 방식**을 사용하면, 페이지 깊이와 상관없이 빠르고 일정한 성능을 보장할 수 있습니다. 정렬 기준 컬럼에 중복이 있을 때는 **PK를 보조 정렬 기준**으로 삼아 데이터 누락을 방지해야 합니다.

### 1. MySQL 에러의 종류 (3가지 분류)
에러 발생 위치에 따라 크게 세 가지로 분류됩니다.

* **Global Error (1~999):** 서버와 클라이언트(드라이버) 양쪽에서 공통적으로 발생할 수 있는 에러.
* **Server Error (1000~1999, 3000~):** MySQL 서버 내부에서 발생하는 에러 (예: 테이블 없음 `1146`).
* **Client Error (2000~2999):** 클라이언트 드라이버나 커넥터 레벨에서 발생하는 에러 (예: 알 수 없는 호스트 접속 `2005`).

* **핵심:** 에러 번호 대역을 알면 문제 해결 시 **조사 범위(서버 vs 클라이언트)**를 좁힐 수 있음.

### 2. 에러 핸들링 시 판단 기준 (무엇을 믿을까?)

#### **❌ 믿으면 안 되는 것**
1.  **에러 메시지 (문자열):**
    * 버전 업그레이드 시 예고 없이 문구가 변경될 수 있음 (예: `Incorrect string value` $\rightarrow$ `Data truncation`).
    * 문자열 파싱으로 에러를 처리하면 마이너 버전 업그레이드만으로도 장애가 발생할 수 있음.
2.  **에러 번호 (Error Code):**
    * 스토리지 엔진(InnoDB, MyISAM 등)에 따라 같은 에러라도 번호가 다를 수 있음 (예: 중복 키 에러 `1062` vs `1022`).
    * `HY000` 등 일부 에러 코드는 버전업 시 변경될 가능성이 있음.

#### **✅ 믿을 만한 것 (권장)**
* **SQL State (5자리 표준 코드):**
    * ANSI SQL 표준을 따르므로 **DBMS 종류나 버전, 스토리지 엔진에 관계없이 일관성**을 가짐.
    * 예: 중복 키 에러는 MySQL, Oracle, SQL Server 모두 `23000`.
    * **예외:** `HY`로 시작하는 SQL State는 미분류 에러이므로 변경 가능성이 있어 주의 필요 (이때는 예외적으로 에러 번호 사용).

### 3. 개발자를 위한 에러 처리 가이드 (Best Practice)
* **SQL Exception 래핑:**
    * 애플리케이션에서 `SQLException`을 잡아서 다른 예외(Custom Exception)로 변환할 때, 원본 `SQLException`을 **절대 버리지 말고 Cause로 포함(Wrapping)**해야 함.
* **에러 정보 전달:**
    * DBA에게 문의할 때는 "쿼리가 안 돼요"가 아니라 **SQL 문장, 에러 번호, SQL State, 에러 메시지** 전체를 전달해야 빠른 원인 파악이 가능함.
* **ORM 사용 시 주의:**
    * ORM이 자체적으로 발생시키는 예외와 DB가 발생시키는 예외를 구분해야 함. 원본 에러 정보가 없으면 이 둘을 구분하기 어려워 해결이 지연됨.

**요약 핵심:**
에러 핸들링 코드를 짤 때는 변동 가능성이 큰 '에러 메시지'나 '에러 번호'보다는 **표준화된 'SQL State'**를 사용하는 것이 가장 안전합니다. 또한, 장애 대응을 위해 **원본 에러 정보(로그)**를 끝까지 유지하는 것이 중요합니다.

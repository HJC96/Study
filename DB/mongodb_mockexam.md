## 📝 MongoDB 모의고사 오답노트

### **Question 8: 버킷 패턴(Bucket Pattern)**

-   **질문 요약**: 버킷 패턴의 주된 사용 사례
-   **정답**: 문서 수를 줄이고 쿼리 성능을 향상시키기 위함
-   **분석**: **버킷 패턴**은 IoT 센서 데이터나 시계열 데이터처럼 짧은 시간 동안 대량의 데이터가 발생하는 경우에 유용합니다. 개별 데이터를 각각의 문서로 만들면 문서 수가 너무 많아지고, 하나의 문서에 모든 데이터를 배열로 넣으면 문서가 너무 커지는 문제가 생깁니다. 버킷 패턴은 이러한 데이터들을 시간별 혹은 특정 기준별 '버킷'이라는 단위로 묶어 **하나의 문서로 그룹화**합니다. 이를 통해 전체 문서 수를 줄이고 관련 데이터를 함께 조회할 수 있어 성능이 향상됩니다.
-   **핵심 정리**: **버킷 패턴**은 대량의 문서를 적절한 크기의 '버킷'으로 그룹화하여 **문서 수를 최적화**하고 **성능을 높이는** 데이터 모델링 기법입니다. 🪣

---

### **Question 23: `findAndModify()`와 `remove` 옵션**

-   **질문 요약**: `db.collection.findAndModify()`에서 `remove` 옵션을 `true`로 설정했을 때의 동작
-   **정답**: 쿼리와 일치하는 첫 번째 문서를 제거함
-   **분석**: `findAndModify()`는 이름 그대로 문서를 '찾고 수정하는' 원자적(atomic) 연산입니다. 여기서 `remove: true` 옵션은 '수정' 작업이 바로 **'삭제'**임을 지정합니다. `findOne...()` 계열의 다른 메서드들처럼, 이 작업은 쿼리 조건과 일치하는 문서가 여러 개이더라도 **첫 번째 문서 하나에만** 영향을 줍니다.
-   **핵심 정리**: `findAndModify({ remove: true })`는 조건에 맞는 **첫 번째 문서를 찾아 삭제**합니다. (참고: 현재는 `findOneAndDelete()` 메서드 사용이 권장됩니다.)

---

### **Question 24: `$sort` 스테이지의 기능**

-   **질문 요약**: 애그리게이션 파이프라인에서 `$sort` 스테이지의 주된 기능
-   **정답**: 지정된 기준으로 파이프라인의 문서를 정렬함
-   **분석**: 애그리게이션 파이프라인에서 `$sort` 스테이지는 이전 스테이지에서 전달받은 문서들을 특정 필드 값을 기준으로 오름차순(`1`) 또는 내림차순(`-1`)으로 **순서를 재배열**하는 단순하고 명확한 역할을 합니다.
-   **핵심 정리**: `$sort`는 **정렬**을 담당하는 스테이지입니다. 🔁

---

### **Question 62: 인덱스 생성 시 성능 저하 작업**

-   **질문 요약**: 필드에 인덱스를 생성할 때 느려지는 경향이 있는 작업
-   **정답**: 인덱스가 걸린 필드에 값을 삽입(insert)하거나 업데이트(update)하는 작업
-   **분석**: 인덱스는 책의 '찾아보기'와 같습니다. 특정 내용을 빠르게 찾도록(read) 도와주지만, 책의 내용을 추가하거나 수정하면(write) '찾아보기' 페이지도 함께 업데이트해야 합니다. 마찬가지로 MongoDB에서도 인덱스가 걸린 필드에 데이터가 추가되거나 변경되면, 데이터뿐만 아니라 **인덱스 자체도 업데이트**해야 하므로 추가적인 작업이 발생하여 쓰기 성능이 저하될 수 있습니다.
-   **핵심 정리**: 인덱스는 **읽기(read) 성능을 향상**시키지만, **쓰기(write) 성능은 저하**시킬 수 있습니다.

---

### **Question 75: 데이터 모델링 (블로그)**

-   **질문 요약**: 블로그 애플리케이션에서 `Articles`(게시글)와 `Authors`(작성자) 정보 모델링 방법
-   **정답**: 각 `article` 문서에 `author`의 ID를 **참조(Reference)**하기
-   **분석**: 한 명의 작성자가 여러 게시글을 쓰는 '일 대 다(One-to-Many)' 관계입니다. 만약 모든 게시글에 작성자의 전체 정보를 **임베딩(Embedding)**하면, 작성자 정보(예: 프로필)가 변경될 때마다 그가 쓴 모든 게시글을 일일이 수정해야 합니다. 이는 매우 비효율적입니다. 대신, `article` 문서에는 `authorId`만 저장하고 `authors` 컬렉션에서 실제 정보를 관리하는 **참조 방식**이 데이터 중복을 막고 정보 업데이트를 용이하게 합니다.
-   **핵심 정리**: 데이터가 중복되고 자주 변경될 가능성이 있다면 **임베딩**보다 **참조** 방식이 유리합니다.

---

### **Question 79: `find`와 `sort`를 위한 인덱스**

-   **질문 요약**: `find({status: ...}).sort({orderDate: ...})` 쿼리에 가장 효과적인 인덱스 조합
-   **정답**: `db.orders.createIndex({ status: 1 })` 와 `db.orders.createIndex({ orderDate: 1 })`
-   **분석**: 이 쿼리는 `status` 필드로 **필터링**하고, `orderDate` 필드로 **정렬**합니다. MongoDB는 이 두 작업을 최적화하기 위해 **인덱스 교차(Index Intersection)**를 사용할 수 있습니다. 즉, `status` 인덱스를 사용해 조건에 맞는 문서를 빠르게 찾고, 그 결과를 `orderDate` 인덱스를 사용해 효율적으로 정렬합니다. 따라서 각 필드에 대한 **두 개의 단일 필드 인덱스**가 효과적인 조합이 될 수 있습니다.
-   **핵심 정리**: `find`와 `sort`에 각각 다른 필드가 사용될 때, 각 필드에 대한 **단일 인덱스**가 좋은 해결책이 될 수 있습니다. (물론 `{ status: 1, orderDate: 1 }` 형태의 복합 인덱스가 가장 이상적입니다.)

---

### **Question 85: 데이터 모델링 (책과 장르)**

-   **질문 요약**: 장르별로 책을 효율적으로 쿼리하기 위한 모델링 방법
-   **정답**: 각 `book` 문서에 `genres` 목록을 **배열로 임베딩(Embedding)**하기
-   **분석**: 책 한 권은 여러 장르를 가질 수 있고, 한 장르는 여러 책을 포함하는 '다 대 다(Many-to-Many)' 관계입니다. '특정 장르의 책 찾기'와 같은 쿼리가 빈번하다면, `book` 문서 안에 `genres: ["Fantasy", "Adventure"]`처럼 장르 목록을 배열로 직접 포함시키는 것이 가장 효율적입니다. 이 `genres` 필드에 **멀티키 인덱스(Multikey Index)**를 생성하면 배열 내의 특정 장르를 매우 빠르게 찾을 수 있습니다.
-   **핵심 정리**: '다 대 다' 관계에서 한쪽을 기준으로 자주 조회한다면, 기준이 되는 데이터를 다른 쪽에 **배열로 임베딩**하는 것이 효율적입니다.

---

### **Question 97: 큰 배열에 대한 쓰기 작업 처리 전략**

-   **질문 요약**: 문서 내의 큰 배열에 대한 쓰기 작업을 처리하는 일반적인 전략
-   **정답**: 배열을 **별도의 문서에 저장**하기
-   **분석**: 한 문서 내의 배열이 계속 커지면, 배열의 일부만 수정해도 MongoDB는 문서 전체를 메모리에 로드했다가 다시 써야 하므로 비효율적입니다. 또한 문서 크기가 16MB 제한에 도달할 위험도 있습니다. 이 문제를 해결하기 위해, 거대한 배열을 별도의 컬렉션이나 문서로 분리하고 원본 문서에서는 그 ID를 참조하는 방식을 사용합니다. 이는 앞서 본 **버킷 패턴**의 원리와도 통합니다.
-   **핵심 정리**: 쓰기가 빈번한 **거대한 배열**은 성능 문제를 유발할 수 있으므로 **별도의 문서로 분리**하는 것을 고려해야 합니다.

---

### **Question 103: 배열 필드 동등성 일치 쿼리용 인덱스**

-   **질문 요약**: 배열 필드 `tags`에서 특정 값을 찾는 쿼리에 가장 효과적인 인덱스 타입
-   **정답**: `tags` 필드에 대한 **단일 필드 인덱스(Single field index)**
-   **분석**: MongoDB에서는 배열을 포함한 필드에 **단일 필드 인덱스**를 생성하면, 내부적으로 **멀티키 인덱스(Multikey Index)**가 자동으로 생성됩니다. 멀티키 인덱스는 배열의 **각 요소에 대해 인덱스 키를 생성**하므로, `db.coll.find({ tags: 'database' })`와 같이 배열 안에 특정 값이 있는지 찾는 쿼리 성능을 극대화합니다.
-   **핵심 정리**: 배열 필드에는 **단일 필드 인덱스**를 걸면 자동으로 **멀티키 인덱스**가 되어 요소 검색에 최적화됩니다.

---

### **Question 28: Atlas Search 자동 완성 인덱스 (건너뛴 문제)**

-   **질문 요약**: `name` 필드에서 부분 단어 검색(자동 완성)을 효율적으로 수행하기 위한 Atlas Search 인덱스 구조
-   **정답**: `tokenization: "edgeGram"`
-   **분석**: 자동 완성 기능은 사용자가 단어의 **시작 부분**을 입력했을 때 일치하는 결과를 찾아야 합니다. **`edgeGram`** 토크나이저는 "Blueberry"라는 단어를 "B", "Bl", "Blu", "Blue"... 와 같이 단어의 시작 부분에서부터 조각(토큰)을 만들어냅니다. 따라서 "Blu"만 입력해도 "Blueberry"를 효율적으로 찾을 수 있습니다.
-   **핵심 정리**: Atlas Search 자동 완성 기능에는 단어의 시작 부분을 기준으로 토큰을 만드는 **`edgeGram`** 토크나이저를 사용합니다.

---

### **Question 51: 대소문자 미구분 텍스트 검색 (건너뛴 문제)**

-   **질문 요약**: `articles` 컬렉션에서 "mongodb"를 대소문자 구분 없이 텍스트 검색하는 방법
-   **정답**: `... .collation({ locale: 'en', strength: 2 })` 사용
-   **분석**: MongoDB의 `$text` 검색은 기본적으로 대소문자를 구분할 수 있습니다. 대소문자를 구분하지 않고 검색하려면 문자열 비교 규칙을 정의하는 **`collation`** 옵션을 사용해야 합니다. `strength: 2`는 대소문자는 무시하지만 발음 구별 기호(예: é, e)는 구분하라는 의미로, 일반적인 대소문자 미구분 검색에 사용됩니다. (`$caseSensitive: false` 옵션은 더 이상 권장되지 않습니다.)
-   **핵심 정리**: `$text` 검색 시 **대소문자를 무시**하려면 쿼리 마지막에 **`.collation({ strength: 2 })`**를 추가합니다.

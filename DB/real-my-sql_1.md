### 1\. 기본 개념 재정립

  * **길이 선언의 의미:** `CHAR(10)`이나 `VARCHAR(10)`의 숫자 10은 바이트(Byte)가 아닌 \*\*글자 수(Character)\*\*를 의미함.
  * **문자셋(Charset)의 영향:**
      * `Latin1`: 고정 길이 (1글자 = 1바이트).
      * `utf8mb4`: 가변 길이 (1글자 = 1\~4바이트).
      * *주의:* `utf8mb4` 사용 시 `CHAR` 타입도 내부적으로는 가변 길이처럼 작동하는 면이 있으나, 공간 할당 방식에서 `VARCHAR`와 차이가 있음.

### 2\. 저장 방식의 차이 (`CHAR` vs `VARCHAR`)

  * **`VARCHAR` (Variable Character)**
      * **공간 효율:** 실제 데이터 길이만큼만 저장 공간을 사용 (+ 길이 정보 저장 1\~2바이트).
      * **특징:** 데이터 길이가 긴 경우 공간 절약에 유리함.
  * **`CHAR` (Character)**
      * **공간 예약:** 실제 데이터 길이와 상관없이 선언된 크기만큼 공간을 미리 확보.
      * **특징:** 남는 공간은 낭비되지만, 업데이트 시 이점이 있음.

### 3\. 핵심: 업데이트(UPDATE)와 성능 이슈

데이터가 수정되어 길이가 늘어날 때의 동작 차이가 성능을 가르는 핵심 요인임.

  * **`VARCHAR`의 문제점 (Row Migration)**
      * 초기에 딱 맞는 공간만 할당했으므로, 수정된 데이터가 더 길어지면 현재 페이지에 저장 공간이 부족할 수 있음.
      * **결과:** 레코드를 다른 페이지로 이동시켜야 함 $\rightarrow$ **단편화(Fragmentation)** 발생 및 성능 저하.
  * **`CHAR`의 장점 (In-place Update)**
      * 처음부터 최대 공간을 예약해 두었으므로, 길이가 늘어나도 예약된 공간 내라면 이동 없이 **제자리 덮어쓰기** 가능.
      * **결과:** 레코드 이동 없음, 단편화 최소화, 성능 유지.

### 4\. 결론: 최적의 선택 기준 (New Standard)

과거의 단순한 기준("고정 길이는 CHAR, 가변은 VARCHAR")을 넘어선 성능 중심의 기준.

| 상황 | 추천 타입 | 이유 |
| :--- | :--- | :--- |
| **길이 변화 폭이 매우 큼** | **`VARCHAR`** | 예: 게시글 본문, 코멘트.<br>공간 낭비를 막는 것이 최우선. |
| **길이 변화 폭이 좁음**<br>+ **빈번한 업데이트** | **`CHAR`** | 예: 상태 코드, 주소, 짧은 메모.<br>공간을 조금 낭비하더라도 **Row Migration을 방지**하여 성능 확보. |
| **고정 길이 데이터** | **`CHAR`** | 예: 주민번호, 해시값, UUID.<br>당연히 `CHAR`가 유리 (단, `VARCHAR`와 성능 차이는 미미함). |

**요약 핵심:**
단순히 데이터 길이의 가변 여부만 보지 말고, \*\*'얼마나 자주 업데이트되는가?'\*\*를 고려해야 함. **빈번하게 수정되는 컬럼**이라면 공간을 희생하더라도 \*\*`CHAR`\*\*를 사용하는 것이 성능상 유리할 수 있음.

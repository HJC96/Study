# 객체 간 상호작용의 시각화 (Sequence Diagram)

## 1. 시퀀스 다이어그램의 목적
* **객체 간 상호작용 (Interaction):** 시스템을 하나의 블랙박스로 보지 않고, 내부를 **화면(View), 로직(Controller), 데이터(Model)** 등의 객체로 나누어 그들 사이의 메시지 흐름을 시간 순서대로 표현함.
* **설계와의 연결:** 분석 모델이지만, 내부 구조를 정의하기 때문에 **설계(Design) 단계**로 자연스럽게 이어지는 가교 역할을 함.

---

## 2. 주요 구성 요소 (Notation) & 패턴 (MVC)
시퀀스 다이어그램 작성 시 시스템 내부를 다음 3가지 객체 유형으로 나누는 패턴(MVC와 유사)을 권장함.



| 요소 | 역할 | 비고 |
| :--- | :--- | :--- |
| **Actor** | 시스템 사용자 (외부) | 학생, 교수 등 |
| **Boundary (View)** | 사용자 인터페이스 (화면) | 입력/출력 담당 |
| **Control (Controller)** | 비즈니스 로직 처리 | 데이터 가공, 판단 담당 |
| **Entity (Model)** | 데이터 저장 및 관리 | DB, 데이터 객체 담당 |

---

## 3. 시나리오 $\rightarrow$ 시퀀스 다이어그램 변환 프로세스

### ① 객체 정의 (Lifeline 설정)
* **Actor:** 학생
* **System 분해:**
    * `수강신청 화면` (Boundary)
    * `수강신청 로직` (Control)
    * `수강신청 데이터` (Entity)
    * *효과: 시스템 내부의 책임 분배가 명확해짐.*

### ② 메시지 흐름 작성 (Message Passing)
시나리오의 문장을 객체 간의 호출(Call)로 변환.

1.  **학생 $\rightarrow$ 화면:** "조회 버튼 클릭" (Request)
2.  **화면 $\rightarrow$ 로직:** "수강 정보 요청" (Call)
3.  **로직 $\rightarrow$ 데이터:** "강의 목록 조회" (Query)
4.  **데이터 $\rightarrow$ 로직 $\rightarrow$ 화면:** 결과 반환 (Return)
5.  **화면 $\rightarrow$ 학생:** "강의 목록 출력" (Display)

### ③ 분기 처리의 한계와 대안
* **한계:** 시퀀스 다이어그램은 `if-else` 같은 복잡한 분기를 표현하기에 그래픽적으로 적합하지 않음 (선이 복잡해짐).
* **대안 (Note 활용):** 다이어그램에 별도의 **노트(Note)**를 달아 "수강신청 기간이 아닐 경우 에러 메시지 출력"과 같은 예외 로직을 텍스트로 명시하여 연결함.
    * *복잡한 분기가 중요하다면 액티비티 다이어그램이 더 유리함.*

---

## 4. 모델링 도구 활용 (Enterprise Architect)
* 유스케이스 하위에 `Interaction` $\rightarrow$ `Sequence Diagram` 생성.
* 툴박스에서 Boundary, Control, Entity 아이콘을 드래그하여 객체를 생성하고 화살표(Message)로 연결.
* **메시지 명:** 시나리오에 있는 구체적인 문장(예: "수강 정보 요청")을 그대로 사용.

## 5. 결론: 어떤 다이어그램을 쓸 것인가?
* **유스케이스 시나리오 (텍스트):** 소설처럼 읽기 쉽고 상세한 묘사 가능.
* **액티비티 다이어그램:** 복잡한 **분기(Branch)**와 **프로세스 흐름** 파악에 유리.
* **시퀀스 다이어그램:** 시스템 내부의 **객체 구조**와 **메시지 호출 순서** 파악에 유리 (설계 및 구현과 직결).
* **전략:** 시스템의 특성과 개발 단계에 맞춰 가장 효과적인 모델링 방식을 선택해야 함.
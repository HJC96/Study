### 1. 프로토타입 패턴이란?
* **개념:** 기존 인스턴스(Prototype)를 **복제(Clone)**하여 새로운 인스턴스를 만드는 패턴임.
* **사용 목적:**
    * 객체 생성 비용(DB 조회, 네트워크 통신, 복잡한 계산 등)이 클 때 유용함.
    * 매번 새로 생성하는 대신, 이미 만들어진 객체를 복사하여 리소스를 절약하고 성능을 최적화함.

### 2. 자바에서의 구현 (`Cloneable`)
* **방법:** `java.lang.Cloneable` 인터페이스를 구현하고, `Object.clone()` 메서드를 오버라이딩하여 사용함.
* **Shallow Copy (얕은 복사):**
    * 자바의 기본 `super.clone()`이 수행하는 방식.
    * 객체의 **참조값(주소)**만 복사됨.
    * **문제점:** 복사본의 내부 객체(Reference Type)를 수정하면 원본도 같이 변경됨.
* **Deep Copy (깊은 복사):**
    * 내부의 참조 객체까지 메모리를 새로 할당하여 완전히 분리된 복사본을 만듦.
    * `clone()` 메서드 내부에서 참조형 필드들을 직접 재생성해주는 로직을 짜야 함.

### 3. 장단점
* **장점:**
    * 복잡한 객체 생성 과정을 숨길 수 있음.
    * 기존 객체를 재활용하므로 성능 효율이 좋음.
* **단점:**
    * 순환 참조가 있는 복잡한 객체의 경우 Deep Copy 구현이 까다로울 수 있음.

### 4. 실무 활용 사례
* **Java Collections:**
    * `ArrayList` 등은 `clone()`을 제공하지만, 반환 타입이 `Object`이고 `List` 인터페이스에는 `clone()`이 없어 잘 안 씀.
    * 대신 **복사 생성자**(`new ArrayList<>(originalList)`) 방식을 주로 사용함.
* **ModelMapper:**
    * 객체 간(예: DTO ↔ Entity) 필드 값을 복사할 때 사용하는 라이브러리.
    * **리플렉션(Reflection)** 기술을 사용하여 지루한 `get/set` 코딩 없이 데이터를 매핑해줌.

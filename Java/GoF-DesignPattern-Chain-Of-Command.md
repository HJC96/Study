### 1. 개념: 요청을 객체로 캡슐화
* **정의:** 요청(Request)을 객체로 감싸서, 요청을 보내는 쪽(Invoker)과 처리하는 쪽(Receiver)을 분리하는 패턴임.
* **핵심:** 요청 내역이 객체에 담기므로, 요청을 파라미터로 넘기거나, 대기열(Queue)에 넣거나, 실행 취소(Undo) 기능을 구현하기 쉬워짐.

### 2. 구조 및 예시 (버튼과 기능)
* **문제:** 버튼(Invoker)이 `Light`(Receiver)를 직접 호출하면, 나중에 `Game`을 실행하는 버튼으로 바꿀 때 버튼 코드를 수정해야 함 (OCP 위반).
* **해결:**
    1.  **Command (인터페이스):** `execute()` 메서드를 정의함.
    2.  **Concrete Command:** `LightOnCommand`, `GameStartCommand` 처럼 실제 수행할 로직을 담은 클래스를 만듦.
    3.  **Invoker (버튼):** 구체적인 기능 대신 `Command` 인터페이스를 가지고, 버튼을 누르면 `command.execute()`를 호출함.
* **결과:** 버튼 코드는 그대로 두고, 주입되는 커맨드 객체만 바꾸면 버튼의 기능이 변경됨.

### 3. 장단점
* **장점:**
    * **결합도 감소 (Decoupling):** 요청하는 객체와 수행하는 객체가 서로 모름.
    * **확장성 (OCP):** 새로운 명령을 추가해도 기존 Invoker 코드는 변경되지 않음.
    * **기능 확장:** 명령 취소(Undo), 재실행(Redo), 로깅, 매크로(여러 명령 실행) 구현이 용이함.
* **단점:**
    * 개별 명령마다 클래스를 만들어야 해서 클래스가 많아지고 구조가 복잡해질 수 있음.

### 4. 실무 활용 사례 (Java & Spring)
* **Java - `Runnable`:**
    * `run()` 메서드 하나만 있는 인터페이스가 커맨드 패턴의 전형적인 예시임.
    * 스레드(Invoker)에게 "할 일(Command)"을 객체로 넘겨주면, 스레드가 이를 실행함.
* **Spring - `SimpleJdbcInsert`:**
    * SQL Insert 실행을 위한 정보(테이블, 데이터 등)를 객체에 담아두고, `execute()`를 호출하여 실행함.
    * 쿼리 실행 요청을 객체화하여 처리하는 커맨드 패턴의 형태를 띰.

### Q1. 불변 객체란?
**A1.** 불변 객체란 객체가 생성된 이후 **그 상태를 절대 변경할 수 없는(Cannot be modified)** 객체입니다. 한 번 초기화된 필드 값은 객체의 수명이 다할 때까지 영원히 유지

### Q2. 불변 객체를 만들기 위한 5가지 핵심 규칙은 ?
**A2.**

1.  **`final` 키워드 사용:** 클래스를 **`final`**로 선언하여 **상속을 금지**합니다. (상속을 허용하면 자식 클래스가 불변성을 깨뜨릴 수 있음.)
2.  **모든 필드를 `private` 및 `final`로 선언:** 모든 상태를 담는 필드에 **`private`** 및 **`final`**을 붙여 외부 접근과 재할당을 원천적으로 막음.
3.  **생성자(Constructor) 외에 수정 메서드(`Setter`)를 제공하지 않음.**
4.  **생성자로 상태를 설정합니다:** 생성자에서 모든 필드를 초기화하며, 클라이언트로부터 받은 값이 유효한지 검사.
5.  **가변 컴포넌트에 대한 방어적 복사본을 생성:** 필드 중에 `Date`나 배열(`Array`)처럼 **가변 객체**가 있다면, 생성자 및 접근자(`Getter`)에서 그 **객체의 복사본(Defensive Copy)**을 반환해야 함. (원본 객체가 외부에서 변경되는 것을 막음)

### Q3. 불변 객체를 선호해야 하는 이유는? (장점)
**A3.** 불변 객체는 가변 객체보다 훨씬 안전하고 견고한 코드를 작성하게 해줌.

1.  **스레드 안전성(Thread Safety):** 객체 상태가 절대 변하지 않으므로, 여러 스레드가 동시에 접근해도 **경쟁 조건(Race Condition)**이 발생할 염려가 X. 따라서 **별도의 동기화(Synchronization)**가 필요 없음.
2.  **재사용 용이성(Reusability):** 상태가 변하지 않으므로, 복잡한 로직 없이 캐시 등에 안전하게 재사용할 수 있음.
3.  **오류 방지:** 객체가 한 번 만들어지면 상태가 변하지 않으므로, 예기치 않은 부작용(Side Effect)으로 인한 **버그**가 발생할 가능성이 거의 없음.
4.  **캡슐화 유지:** 객체 내부 상태가 외부로 유출되거나 변경될 일이 없어 캡슐화 원칙이 강력하게 지켜짐.

### Q4. 불변 객체의 단점은?
**A4.** 객체의 상태를 자주 변경해야 할 경우 **성능 문제**가 발생가능.

* 상태가 조금이라도 변경될 때마다 **새로운 객체**를 만들어야 함. 이 과정에서 가비지 컬렉션(GC) 부하가 증가할 수 있음.
* **해결책:** 상태 변경이 잦은 경우에는 **가변 동반 클래스(Mutable Companion Class)**(예: `String`에 대한 `StringBuilder`)를 사용하여 작업하고, 최종 결과만 불변 객체로 만드는 것이 효율적.

### Q5. 불변 객체와 상속 금지의 관계는 ?
**A5.**

* **이유:** 상속을 허용하면 자식 클래스가 부모의 불변 메서드(예: `add()`)를 재정의(Override)하여 내부적으로 상태를 변경하는 **가변 클래스**로 만들 수 있음.
* 불변 클래스 설계자는 **상속을 통한 오용을 방지**하기 위해 클래스를 `final`로 만들거나, 모든 생성자를 `private` 또는 `package-private`으로 선언하여 상속 자체를 막아야 함.
* 이는 우리가 "상속보다는 컴포지션(합성)을 사용하라"고 배웠던 **Item 18**과 일맥상통하는 내용.


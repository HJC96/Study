### Q1. 공변(Covariant)이란 무엇임?
A1. **공변성**이란, `String`이 `Object`의 자식 타입일 때, `String[]`도 `Object[]`의 자식 타입으로 취급되는 관계임. 즉, **타입의 상속 관계가 컨테이너(배열)에 그대로 유지**되는 것임.

### Q2. 불공변(Invariant)이란 무엇임?
A2. **불공변성**이란, `String`이 `Object`의 자식 타입이더라도, **`List<String>`은 `List<Object>`의 자식 타입이 아님.** 두 타입은 그냥 별개의 타입으로 취급됨. 즉, **타입의 상속 관계가 컨테이너(제네릭)에 적용되지 않는** 것임.

### Q3. 배열과 제네릭의 가장 근본적인 차이는 무엇임?
A3. 타입 시스템에서 동작하는 방식이 다름.
* **배열(Array): 공변적(Covariant)임.**
* **제네릭(Generic): 불공변적(Invariant)임.**
이 차이 때문에 배열은 런타임에 타입 안전성이 깨질 수 있지만, 제네릭은 컴파일 시점에 타입 안전성을 보장함.

### Q4. 배열의 '공변성'이 왜 위험함?
A4. **타입 안전성을 위반**하고, 오류를 **런타임에 발견**하게 만들기 때문임.
`String[]`을 `Object[]` 변수에 할당하는 게 컴파일 시에는 허용됨. 하지만 이 `Object[]` 변수로 `Integer` 같은 엉뚱한 타입을 넣으려는 시도가 런타임 전까지 안 잡힘. 이 코드는 **실행 시 `ArrayStoreException` 예외를 발생**시킴.

### Q5. 제네릭의 '불공변성'이 더 안전한 이유는 무엇임?
A5. 위험한 상황 자체를 **컴파일 에러**로 즉시 막아주기 때문임.
`List<String>`을 `List<Object>` 변수에 할당하려는 시도 자체가 문법적으로 금지됨. 그래서 배열처럼 `List<String>`에 `Integer`를 실수로 넣을 가능성이 원천 차단되어, **컴파일 시점에 타입 안전성을 확보**할 수 있음.

### Q6. 배열과 제네릭은 런타임에 타입을 어떻게 다룸?
A6.
* **배열 (실체화, Reified):** 런타임에도 자신이 `String[]`인지 `Integer[]`인지 **타입을 정확히 앎.** (그래서 `ArrayStoreException`을 터뜨릴 수 있음.)
* **제네릭 (타입 소거, Type Erasure):** 런타임에는 `<String>` 같은 **타입 정보가 사라지고** 그냥 `List`처럼 로(raw) 타입으로 동작함. (하위 호환성 때문임.)

### Q7. `new List<String>[]` 같은 제네릭 배열을 만들 수 없는 이유는 무엇임?
A7. 허용하면 **자바의 타입 시스템이 붕괴**되기 때문임. 만약 제네릭 배열 생성이 허용된다면,
1.  배열의 **'공변성'** 룰에 따라 `List<String>[]`을 `Object[]`로 형 변환할 수 있음.
2.  그 `Object[]` 변수에 `List<Integer>`를 넣을 수 있음. (런타임에는 둘 다 `List`라서 `ArrayStoreException`이 안 남.)
3.  결국, 원래 `List<String>[]` 변수에서 원소를 꺼내 `String`으로 쓰려는 순간, 실제로는 `Integer`가 들어있어서 **`ClassCastException`이 발생**함.

자바는 이 런타임 재앙을 막기 위해, **제네릭 배열 생성 자체를 컴파일 에러로 금지**함.

### Q8. `Class<?>`는 무엇을 의미함?
A8. **"알 수 없는 어떤 특정 타입(unknown type)의 `Class` 객체"**를 의미하는 제네릭 타입임. `List.class` 같은 클래스 리터럴 객체를 변수에 담을 때, 로 타입(raw type)인 `Class` 대신 `Class<?>`를 써야 컴파일러 경고가 안 뜨고 타입 안정성을 높일 수 있음.


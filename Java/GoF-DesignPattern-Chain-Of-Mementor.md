### 1. 개념: 상태의 저장과 복원
* **정의:** 객체의 내부 상태를 캡슐화(Encapsulation)를 깨지 않고 저장해 두었다가, 나중에 그 상태로 복원할 수 있게 하는 패턴임.
* **핵심:** `Originator`(원래 객체)의 내부 정보를 외부(`Caretaker`)에 노출하지 않으면서도 저장(`Memento`)하고 복구할 수 있어야 함.

### 2. 구조 및 예시 (게임 세이브)
* **문제:** 게임(`Game`)의 점수(`redScore`, `blueScore`)를 저장하고 싶은데, 클라이언트가 이 필드들에 직접 접근하게 하면 캡슐화가 깨지고 게임 내부 구조 변경 시 클라이언트 코드도 수정해야 함.
* **해결:**
    1.  **Originator (`Game`):** 현재 상태를 `Memento` 객체로 만들어 반환하는 `save()`와, `Memento`를 받아 상태를 복원하는 `restore(Memento)` 메서드를 제공함.
    2.  **Memento (`GameSave`):** `Game`의 내부 상태(점수들)를 저장하는 객체. **불변(Immutable)**이어야 하며, 데이터를 수정할 수 없게 `final` 등으로 보호함.
    3.  **Caretaker (`Client`):** `Memento` 객체를 보관하고 있다가 필요할 때 `Originator`에게 다시 돌려주어 복원을 요청함. `Memento` 내부의 값을 조작하거나 알 필요는 없음.

### 3. 장단점
* **장점:**
    * **캡슐화 유지:** 저장된 상태(Memento)를 사용하는 쪽(Caretaker)은 그 안에 뭐가 들었는지 몰라도 됨.
    * **유연성:** 내부 상태 구조가 바뀌어도 Memento 생성 로직만 수정하면 되므로 클라이언트 코드는 안전함.
    * **상태 스냅샷:** 객체의 상태를 쉽게 저장하고 복구(Undo/Redo)할 수 있음.
* **단점:**
    * **메모리 사용량:** 상태를 저장할 때마다 Memento 객체가 생성되므로, 상태가 크거나 자주 저장하면 메모리 부담이 될 수 있음.

### 4. 실무 활용 사례 (Java)
* **객체 직렬화 (`Serializable`):**
    * 객체를 바이트 스트림으로 변환(직렬화)하여 파일이나 네트워크로 저장했다가, 다시 객체로 복원(역직렬화)하는 기능.
    * 객체의 상태를 외부(파일 등)에 저장하고 다시 불러온다는 점에서 메멘토 패턴의 개념과 유사함.
    * 단, 역직렬화 시 보안 이슈나 성능 문제를 고려해야 함.
* **`java.util.Date`:**
    * 내부의 타임스탬프 값(`long`)을 통해 날짜를 저장하고 복원하는 방식이 메멘토 패턴의 단순한 형태라고 볼 수도 있음.


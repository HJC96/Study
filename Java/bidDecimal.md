소수점 연산이 필요할때 BidDecimal 사용이 필요하다.
Double 타입을 사용할 경우, 부동소수점 방식의 특성 때문에 오차가 발생할 수 있다.

아래는 perplexity에게 물어본 결과이다.
---
### 왜 BigDecimal을 사용할까?

Java에서 **BigDecimal**을 사용하는 가장 큰 이유는 **정확한 소수점 연산**이 필요할 때입니다. 특히 **Double** 타입을 사용할 경우, 부동소수점 방식의 특성 때문에 **오차(정밀도 손실)**가 발생할 수 있습니다.

#### Double의 한계

- Double은 **64비트**로 표현되는 부동소수점 타입입니다.
- 컴퓨터는 0.1, 0.2 같은 10진수 소수를 **이진수로 정확하게 표현하지 못합니다**. 예를 들어, `0.1 + 0.2`의 결과가 정확히 0.3이 아니라 `0.30000000000000004`처럼 나올 수 있습니다[1][2][3].
- 이런 **작은 오차**가 누적되면, 금융 계산이나 정밀한 소수점 연산에서는 심각한 문제가 될 수 있습니다.

#### BigDecimal의 장점

- **임의 정밀도(Arbitrary Precision)**: 원하는 만큼 소수점 이하 자리수를 정확하게 표현할 수 있습니다.
- **정확한 값 표현**: 0.1, 0.2, 0.3 등 소수점 숫자를 **정확하게 저장하고 계산**할 수 있습니다.
- **금융/과학 계산에 적합**: 돈, 통화, 세금 등 **정확한 소수점 연산이 필요한 경우**에 필수적으로 사용됩니다[4][1][5][6].

#### Double vs. BigDecimal 비교

| 항목         | Double                      | BigDecimal            |
|--------------|----------------------------|-----------------------|
| 정밀도       | 제한적(15~16자리)           | 임의(필요한 만큼)     |
| 속도         | 빠름                        | 느림                  |
| 메모리 사용  | 적음                        | 많음                  |
| 사용 예시    | 일반 연산, 과학 계산         | 금융, 회계, 정확한 연산|
| 오차 발생    | 있음                        | 없음(정확)            |

#### 언제 BigDecimal을 써야 할까?

- **돈, 세금, 통화 등** 소수점 자리 하나하나가 중요한 경우
- 누적 오차가 문제가 될 수 있는 반복 연산
- 결과의 **정확성**이 최우선인 비즈니스 로직

#### 참고 예시

```java
System.out.println(0.1 + 0.2); // 0.30000000000000004 (Double)
System.out.println(new BigDecimal("0.1").add(new BigDecimal("0.2"))); // 0.3 (BigDecimal)
```
Double로는 오차가 생기지만, BigDecimal은 정확한 결과를 보장합니다[1][2].

#### 결론

- **정확한 소수점 연산이 필요하다면 BigDecimal을 사용**하는 것이 맞습니다.
- Double은 속도와 메모리 면에서 유리하지만, 오차가 발생할 수 있으니 상황에 따라 적절히 선택해야 합니다[4][1][6][7].


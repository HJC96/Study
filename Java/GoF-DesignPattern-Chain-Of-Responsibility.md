1. 개념: 책임을 연결하다
정의: 요청을 처리하는 여러 객체(Handler)를 체인(사슬) 형태로 연결해두고, 요청이 들어오면 체인을 따라가며 처리하거나 다음 객체로 넘기는 패턴임.

핵심:

SRP (단일 책임 원칙): 인증, 로깅, 비즈니스 로직 등을 하나의 거대한 클래스에 때려 넣지 않고, 각자 할 일만 하는 별도 클래스로 분리함.

결합도 감소: 요청을 보내는 쪽(Client)은 누가 이 요청을 처리할지 구체적으로 몰라도 됨.

2. 구현 방법 (핸들러 체인)
문제: RequestHandler 하나에 인증 체크, 로깅, 본문 출력을 다 넣으면 코드가 복잡하고 유지보수가 어려움.

패턴 적용:

Handler (추상 클래스/인터페이스): 다음 핸들러를 가리키는 nextHandler 필드와 handle() 메서드를 정의함.

Concrete Handlers:

AuthHandler: 인증 체크 후 성공하면 next, 실패하면 중단.

LoggingHandler: 로그를 남기고 next.

PrintHandler: 실제 비즈니스 로직 수행.

Client: 핸들러들을 순서대로 조립(Link)하고 요청을 던짐.

3. 장단점
장점:

유연성 & 확장성 (OCP): 클라이언트 코드를 건드리지 않고도 새로운 처리 단계(예: 캐싱)를 체인 중간에 끼워 넣거나 순서를 바꿀 수 있음.

책임 분리: 각 핸들러는 자기 일에만 집중하면 됨.

단점:

디버깅의 어려움: 실행 흐름이 여러 객체를 타넘어 다니기 때문에 추적하기가 다소 복잡할 수 있음.

처리 보장 없음: 체인 끝까지 갔는데도 아무도 처리를 안 하고 그냥 끝나는 경우가 생길 수 있음 (설계 시 주의 필요).

4. 실무 활용 사례 (Java & Spring)
Java - Servlet Filter:

가장 대표적인 예시.

웹 요청이 오면 서블릿에 닿기 전에 EncodingFilter, AuthFilter 등을 거침.

chain.doFilter()를 호출하여 다음 단계로 요청을 넘김.

Spring - Spring Security:

스프링 시큐리티는 거대한 필터 체인으로 구성되어 있음.

요청이 들어오면 설정된 순서대로 인증 필터, 권한 필터 등을 통과하며 보안 검사를 수행함.

팩토리 메서드 패턴의 개념, 구현 방법, 그리고 클라이언트 코드 처리에 대한 내용을 요약함.

### 1. 문제점: 나쁜 구조 (Strong Coupling)
* **상황:** 기존 `WhiteShip`만 만들던 공장에서 `BlackShip`도 만들어야 함.
* **잘못된 접근:** `orderShip()` 메서드 안에 `if (name.equals("BlackShip"))` 분기 처리를 추가함.
* **결과:**
    * 코드가 복잡해지고 지저분해짐.
    * 새로운 배를 추가할 때마다 기존 코드를 수정해야 하므로 **OCP(개방-폐쇄 원칙)** 를 위반함.

### 2. 해결책: 팩토리 메서드 패턴 적용
* **핵심:** 객체 생성의 책임을 **서브 클래스(구체적인 팩토리)** 에게 위임하는 것임.
* **구조:**
    * **Creator (Interface/Abstract):** 공통 공정(`orderShip`, `validate` 등)은 구현하고, 객체 생성(`createShip`)은 추상 메서드로 남김.
    * **Concrete Creator:** `WhiteShipFactory`, `BlackShipFactory` 처럼 실제 팩토리를 구현하여 각각 맞는 인스턴스를 반환함.



### 3. 구현의 장점 (OCP 준수)
* **확장성:** `BlackShip`을 추가할 때 기존 `WhiteShipFactory`나 `ShipFactory` 인터페이스 코드를 **전혀 수정할 필요 없음.**
* **유연성:** `BlackShipFactory` 클래스를 새로 만들고 상속받기만 하면 됨. (확장에는 열려 있고, 변경에는 닫혀 있음).

### 4. 자바 버전에 따른 구현 디테일
* **Java 9 이상:** 인터페이스 안에 `private` 메서드 구현이 가능하여, 공통 로직을 인터페이스 내부에 깔끔하게 숨길 수 있음.
* **Java 8:** `default` 메서드는 가능하지만 `private` 메서드는 불가함.
    * **대안:** 인터페이스와 구체적인 팩토리 사이에 `DefaultShipFactory` 같은 **추상 클래스**를 두어 공통 로직을 처리함.
* **핵심:** 인터페이스냐 추상 클래스냐보다 **"구체적인 제품 생성을 하위 클래스가 결정한다"** 는 패턴의 의도가 중요함.

### 5. 클라이언트 코드의 변경과 DI
* **문제:** 클라이언트에서 `new WhiteShipFactory()` 처럼 구체적인 팩토리를 생성하면, 팩토리 교체 시 클라이언트 코드도 바뀜.
* **해결 (DI):**
    * 클라이언트는 인터페이스(`ShipFactory`)에만 의존하게 작성함.
    * 외부에서 구체적인 팩토리(`new WhiteShipFactory`)를 주입(Dependency Injection)해 주는 방식을 사용하면 클라이언트 코드 변경을 최소화할 수 있음.

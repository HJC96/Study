### 1. 개념: 알고리즘의 캡슐화와 교체
* **정의:** 어떤 작업을 수행하는 여러 가지 알고리즘들을 각각 하나의 클래스로 캡슐화하고, 이들을 교체 가능하게 만드는 패턴임.
* **핵심:**
    * **Context:** 전략을 사용하는 주체 (예: 게임).
    * **Strategy (인터페이스):** 알고리즘들의 공통 인터페이스 (예: `Speed`).
    * **Concrete Strategy:** 실제 알고리즘 구현체 (예: `Normal`, `Faster`).
* **목적:** 알고리즘을 사용하는 클라이언트 코드(`Context`)를 변경하지 않고도, 알고리즘(`Strategy`)을 자유롭게 바꿀 수 있음.

### 2. 구현 예시 (무궁화 꽃이 피었습니다 게임)
* **문제:** 게임 속도(`Speed`)가 바뀔 때마다 `BlueLightRedLight` 클래스 내부의 `if-else` 분기문을 계속 수정해야 한다면 유지보수가 어려움.
* **해결:**
    1.  `Speed` 인터페이스 정의.
    2.  `Normal`, `Faster` 클래스에서 각각의 속도 로직 구현.
    3.  게임 클래스는 `Speed` 인터페이스를 주입받아 사용.
* **결과:** `Fastest` 같은 새로운 속도를 추가해도 게임 클래스 코드는 전혀 수정할 필요가 없음 (OCP 준수).

### 3. 장단점
* **장점:**
    * **확장성 (OCP):** 새로운 전략 추가 시 기존 코드를 건드리지 않음.
    * **유연성:** 런타임(실행 중)에 전략을 교체할 수 있음.
    * **상속 대신 위임:** 상속의 단점(강한 결합)을 피하고 조합(Composition)을 통해 유연함을 얻음.
* **단점:**
    * **복잡도 증가:** 전략마다 클래스를 만들어야 해서 클래스 수가 늘어남.
    * **클라이언트의 책임:** 클라이언트가 구체적인 전략을 알고 직접 주입해줘야 함.

### 4. 실무 활용 사례 (Java & Spring)
* **Java - `Comparator`:**
    * 정렬 로직(`sort`)은 그대로 두고, 정렬 기준(`Comparator` 구현체)만 바꿔 끼워 사용함. 대표적인 전략 패턴.
* **Spring - `ApplicationContext`, `PlatformTransactionManager`:**
    * 스프링은 인터페이스 기반 설계가 많아 전략 패턴이 매우 흔함.
    * 예: `PlatformTransactionManager` 인터페이스 뒤에 `DataSourceTransactionManager`(JDBC용), `JpaTransactionManager`(JPA용) 등 다양한 구현체가 존재하며, 설정에 따라 갈아 끼워짐.

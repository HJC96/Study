### 1. 개념: 순회 방식의 추상화
* **정의:** 집합 객체(리스트, 트리, 배열 등)의 내부 구조를 노출하지 않고, 안에 들어있는 요소들을 **순회(Iteration)**할 수 있는 방법을 제공하는 패턴임.
* **핵심:** `Aggregate`(집합체)와 `Iterator`(반복자)를 분리하여, 집합체의 내부 구조가 바뀌어도 클라이언트 코드는 변경되지 않도록 함.

### 2. 구현 예시 (게시판)
* **문제:** 게시판(`Board`) 내부의 게시물(`List<Post>`)을 순회할 때, 클라이언트가 `List`라는 구체적인 타입에 의존하면 나중에 `Set`이나 `Array`로 바꿀 때 클라이언트 코드도 수정해야 함.
* **해결:**
    1.  `Board`는 `Iterator<Post>`를 반환하는 메서드(`getIterator()`)를 제공함.
    2.  `RecentPostIterator` 같은 구체적인 반복자를 만들어 최신순 정렬 등 순회 로직을 캡슐화함.
    3.  클라이언트는 `Iterator` 인터페이스( `hasNext()`, `next()` )만 사용하여 순회함.
* **결과:** `Board` 내부가 어떻게 생겼든 클라이언트는 `iterator`만 받아서 돌리면 됨.

### 3. 장단점
* **장점:**
    * **SRP (단일 책임 원칙):** 집합 객체는 데이터 관리에, 이터레이터는 순회에 집중함.
    * **OCP (개방-폐쇄 원칙):** 새로운 순회 방식(예: 제목순 정렬)을 추가해도 기존 코드는 변경되지 않음.
    * **일관된 인터페이스:** 어떤 컬렉션이든 동일한 방법으로 순회 가능.
* **단점:**
    * 클래스가 늘어나고 구조가 복잡해질 수 있음 (간단한 컬렉션이면 그냥 `for-each` 쓰는 게 나을 수 있음).

### 4. 실무 활용 사례 (Java & Spring)
* **Java - `java.util.Iterator`:**
    * 가장 대표적인 예시. `List`, `Set` 등 모든 컬렉션이 `iterator()`를 제공함.
    * **StAX (Streaming API for XML):** XML을 요소(Element) 단위로 순회하며 읽거나 쓸 때 이터레이터 패턴을 사용함 (메모리 효율적).
* **Spring - `CompositeIterator`:**
    * 여러 이터레이터를 조합해서 하나의 이터레이터처럼 사용할 수 있게 해주는 기능 (많이 쓰이지는 않음).

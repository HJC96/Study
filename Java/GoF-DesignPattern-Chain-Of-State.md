### 1. 개념: 상태에 따른 행동 변화
* **정의:** 객체의 내부 상태가 변경됨에 따라 객체의 행동(Behavior)이 달라지도록 하는 패턴임.
* **핵심:**
    * **Context:** 상태를 가지고 있는 주체 (예: `OnlineCourse`).
    * **State (인터페이스):** 상태에 따라 달라지는 행동들을 정의한 인터페이스.
    * **Concrete State:** 각 상태별 구체적인 행동을 구현한 클래스 (예: `Draft`, `Published`, `Private`).
* **비유:** 리모컨의 전원 버튼을 눌렀을 때, TV가 켜져 있으면 '끄기', 꺼져 있으면 '켜기'로 동작하는 것과 같음.

### 2. 구현 예시 (온라인 강의 시스템)
* **문제:** `OnlineCourse`가 `Draft`(작성중), `Published`(공개), `Private`(비공개) 상태를 가짐. 학생 추가(`addStudent`)나 리뷰 작성(`addReview`) 시 상태에 따라 `if-else` 문이 복잡하게 얽혀 있어 유지보수가 어려움.
* **해결:**
    1.  `State` 인터페이스 정의 (`addStudent()`, `addReview()` 메서드 포함).
    2.  각 상태(`Draft`, `Published`, `Private`)를 클래스로 분리하여 `State` 인터페이스를 구현.
        * 예: `Draft` 상태에서는 리뷰 작성 불가(`UnsupportedOperationException`), 학생 추가는 가능.
        * 예: `Private` 상태에서는 특정 학생만 추가 가능.
    3.  `OnlineCourse`(Context)는 `State` 객체를 가지고, 요청이 오면 `state.addStudent()` 처럼 상태 객체에게 행동을 위임함.
* **결과:** 복잡한 `if-else` 문이 사라지고, 상태별 로직이 각 클래스에 응집됨.

### 3. 장단점
* **장점:**
    * **SRP (단일 책임 원칙):** 특정 상태와 관련된 로직이 한 곳(State 클래스)에 모임.
    * **OCP (개방-폐쇄 원칙):** 새로운 상태를 추가해도 기존 Context 코드는 변경되지 않음.
    * **가독성 및 유지보수성:** 복잡한 조건문이 사라져 코드가 깔끔해짐.
* **단점:**
    * **클래스 증가:** 상태별로 클래스를 만들어야 하므로 파일 개수가 늘어남.
    * **오버 엔지니어링:** 상태가 적고 로직이 단순한 경우에는 오히려 구조를 복잡하게 만들 수 있음.

### 4. 실무 활용 사례 (Java & Spring)
* 자바나 스프링 라이브러리 내부에서 명확한 상태 패턴 예제를 찾기는 쉽지 않음. 주로 비즈니스 로직(주문 상태, 결제 상태, 배포 프로세스 등)을 구현할 때 많이 사용되는 패턴임.

